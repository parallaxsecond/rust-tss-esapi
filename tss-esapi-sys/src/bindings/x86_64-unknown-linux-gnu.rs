/* automatically generated by rust-bindgen 0.69.4 */
/* TPM2_TSS_VERSION="3.2.2" */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TSS2_RC_LAYER_SHIFT: u32 = 16;
pub const TSS2_BASE_RC_GENERAL_FAILURE: u32 = 1;
pub const TSS2_BASE_RC_NOT_IMPLEMENTED: u32 = 2;
pub const TSS2_BASE_RC_BAD_CONTEXT: u32 = 3;
pub const TSS2_BASE_RC_ABI_MISMATCH: u32 = 4;
pub const TSS2_BASE_RC_BAD_REFERENCE: u32 = 5;
pub const TSS2_BASE_RC_INSUFFICIENT_BUFFER: u32 = 6;
pub const TSS2_BASE_RC_BAD_SEQUENCE: u32 = 7;
pub const TSS2_BASE_RC_NO_CONNECTION: u32 = 8;
pub const TSS2_BASE_RC_TRY_AGAIN: u32 = 9;
pub const TSS2_BASE_RC_IO_ERROR: u32 = 10;
pub const TSS2_BASE_RC_BAD_VALUE: u32 = 11;
pub const TSS2_BASE_RC_NOT_PERMITTED: u32 = 12;
pub const TSS2_BASE_RC_INVALID_SESSIONS: u32 = 13;
pub const TSS2_BASE_RC_NO_DECRYPT_PARAM: u32 = 14;
pub const TSS2_BASE_RC_NO_ENCRYPT_PARAM: u32 = 15;
pub const TSS2_BASE_RC_BAD_SIZE: u32 = 16;
pub const TSS2_BASE_RC_MALFORMED_RESPONSE: u32 = 17;
pub const TSS2_BASE_RC_INSUFFICIENT_CONTEXT: u32 = 18;
pub const TSS2_BASE_RC_INSUFFICIENT_RESPONSE: u32 = 19;
pub const TSS2_BASE_RC_INCOMPATIBLE_TCTI: u32 = 20;
pub const TSS2_BASE_RC_NOT_SUPPORTED: u32 = 21;
pub const TSS2_BASE_RC_BAD_TCTI_STRUCTURE: u32 = 22;
pub const TSS2_BASE_RC_MEMORY: u32 = 23;
pub const TSS2_BASE_RC_BAD_TR: u32 = 24;
pub const TSS2_BASE_RC_MULTIPLE_DECRYPT_SESSIONS: u32 = 25;
pub const TSS2_BASE_RC_MULTIPLE_ENCRYPT_SESSIONS: u32 = 26;
pub const TSS2_BASE_RC_RSP_AUTH_FAILED: u32 = 27;
pub const TSS2_BASE_RC_NO_CONFIG: u32 = 28;
pub const TSS2_BASE_RC_BAD_PATH: u32 = 29;
pub const TSS2_BASE_RC_NOT_DELETABLE: u32 = 30;
pub const TSS2_BASE_RC_PATH_ALREADY_EXISTS: u32 = 31;
pub const TSS2_BASE_RC_KEY_NOT_FOUND: u32 = 32;
pub const TSS2_BASE_RC_SIGNATURE_VERIFICATION_FAILED: u32 = 33;
pub const TSS2_BASE_RC_HASH_MISMATCH: u32 = 34;
pub const TSS2_BASE_RC_KEY_NOT_DUPLICABLE: u32 = 35;
pub const TSS2_BASE_RC_PATH_NOT_FOUND: u32 = 36;
pub const TSS2_BASE_RC_NO_CERT: u32 = 37;
pub const TSS2_BASE_RC_NO_PCR: u32 = 38;
pub const TSS2_BASE_RC_PCR_NOT_RESETTABLE: u32 = 39;
pub const TSS2_BASE_RC_BAD_TEMPLATE: u32 = 40;
pub const TSS2_BASE_RC_AUTHORIZATION_FAILED: u32 = 41;
pub const TSS2_BASE_RC_AUTHORIZATION_UNKNOWN: u32 = 42;
pub const TSS2_BASE_RC_NV_NOT_READABLE: u32 = 43;
pub const TSS2_BASE_RC_NV_TOO_SMALL: u32 = 44;
pub const TSS2_BASE_RC_NV_NOT_WRITEABLE: u32 = 45;
pub const TSS2_BASE_RC_POLICY_UNKNOWN: u32 = 46;
pub const TSS2_BASE_RC_NV_WRONG_TYPE: u32 = 47;
pub const TSS2_BASE_RC_NAME_ALREADY_EXISTS: u32 = 48;
pub const TSS2_BASE_RC_NO_TPM: u32 = 49;
pub const TSS2_BASE_RC_BAD_KEY: u32 = 50;
pub const TSS2_BASE_RC_NO_HANDLE: u32 = 51;
pub const TSS2_BASE_RC_NOT_PROVISIONED: u32 = 52;
pub const TSS2_BASE_RC_ALREADY_PROVISIONED: u32 = 53;
pub const TSS2_LAYER_IMPLEMENTATION_SPECIFIC_OFFSET: u32 = 63488;
pub const TSS2_LEVEL_IMPLEMENTATION_SPECIFIC_SHIFT: u32 = 11;
pub const TPM2_MAX_COMMAND_SIZE: u32 = 4096;
pub const TPM2_MAX_RESPONSE_SIZE: u32 = 4096;
pub const TPM2_NUM_PCR_BANKS: u32 = 16;
pub const TPM2_MAX_DIGEST_BUFFER: u32 = 1024;
pub const TPM2_MAX_NV_BUFFER_SIZE: u32 = 2048;
pub const TPM2_MAX_PCRS: u32 = 32;
pub const TPM2_MAX_ALG_LIST_SIZE: u32 = 128;
pub const TPM2_MAX_CAP_CC: u32 = 256;
pub const TPM2_MAX_CAP_BUFFER: u32 = 1024;
pub const TPM2_MAX_CONTEXT_SIZE: u32 = 5120;
pub const TPM2_SHA_DIGEST_SIZE: u32 = 20;
pub const TPM2_SHA1_DIGEST_SIZE: u32 = 20;
pub const TPM2_SHA256_DIGEST_SIZE: u32 = 32;
pub const TPM2_SHA384_DIGEST_SIZE: u32 = 48;
pub const TPM2_SHA512_DIGEST_SIZE: u32 = 64;
pub const TPM2_SM3_256_DIGEST_SIZE: u32 = 32;
pub const TPM2_MAX_SYM_BLOCK_SIZE: u32 = 16;
pub const TPM2_MAX_SYM_DATA: u32 = 256;
pub const TPM2_MAX_ECC_KEY_BYTES: u32 = 128;
pub const TPM2_MAX_SYM_KEY_BYTES: u32 = 32;
pub const TPM2_MAX_RSA_KEY_BYTES: u32 = 512;
pub const TPM2_LABEL_MAX_BUFFER: u32 = 32;
pub const TPM2_PCR_SELECT_MAX: u32 = 4;
pub const TPM2_PRIVATE_VENDOR_SPECIFIC_BYTES: u32 = 1280;
pub const TPMA_LOCALITY_EXTENDED_SHIFT: u32 = 5;
pub const TPMA_CC_COMMANDINDEX_SHIFT: u32 = 0;
pub const TPMA_CC_CHANDLES_SHIFT: u32 = 25;
pub const TPMA_CC_RES_SHIFT: u32 = 30;
pub const TPM2_NO: u32 = 0;
pub const TPM2_YES: u32 = 1;
pub const TPM2_NV_INDEX_INDEX_SHIFT: u32 = 0;
pub const TPM2_NV_INDEX_RH_NV_SHIFT: u32 = 24;
pub const TPMA_NV_TPM2_NT_SHIFT: u32 = 4;
pub const _SYS_POLL_H: u32 = 1;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLRDNORM: u32 = 64;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRNORM: u32 = 256;
pub const POLLWRBAND: u32 = 512;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const TSS2_TCTI_TIMEOUT_BLOCK: i32 = -1;
pub const TSS2_TCTI_TIMEOUT_NONE: u32 = 0;
pub const TSS2_TCTI_INFO_SYMBOL: &[u8; 15] = b"Tss2_Tcti_Info\0";
pub const TSS2_SYS_MAX_SESSIONS: u32 = 3;
pub const ESYS_TR_NONE: u32 = 4095;
pub const ESYS_TR_PASSWORD: u32 = 255;
pub const ESYS_TR_PCR0: u32 = 0;
pub const ESYS_TR_PCR1: u32 = 1;
pub const ESYS_TR_PCR2: u32 = 2;
pub const ESYS_TR_PCR3: u32 = 3;
pub const ESYS_TR_PCR4: u32 = 4;
pub const ESYS_TR_PCR5: u32 = 5;
pub const ESYS_TR_PCR6: u32 = 6;
pub const ESYS_TR_PCR7: u32 = 7;
pub const ESYS_TR_PCR8: u32 = 8;
pub const ESYS_TR_PCR9: u32 = 9;
pub const ESYS_TR_PCR10: u32 = 10;
pub const ESYS_TR_PCR11: u32 = 11;
pub const ESYS_TR_PCR12: u32 = 12;
pub const ESYS_TR_PCR13: u32 = 13;
pub const ESYS_TR_PCR14: u32 = 14;
pub const ESYS_TR_PCR15: u32 = 15;
pub const ESYS_TR_PCR16: u32 = 16;
pub const ESYS_TR_PCR17: u32 = 17;
pub const ESYS_TR_PCR18: u32 = 18;
pub const ESYS_TR_PCR19: u32 = 19;
pub const ESYS_TR_PCR20: u32 = 20;
pub const ESYS_TR_PCR21: u32 = 21;
pub const ESYS_TR_PCR22: u32 = 22;
pub const ESYS_TR_PCR23: u32 = 23;
pub const ESYS_TR_PCR24: u32 = 24;
pub const ESYS_TR_PCR25: u32 = 25;
pub const ESYS_TR_PCR26: u32 = 26;
pub const ESYS_TR_PCR27: u32 = 27;
pub const ESYS_TR_PCR28: u32 = 28;
pub const ESYS_TR_PCR29: u32 = 29;
pub const ESYS_TR_PCR30: u32 = 30;
pub const ESYS_TR_PCR31: u32 = 31;
pub const ESYS_TR_RH_OWNER: u32 = 257;
pub const ESYS_TR_RH_NULL: u32 = 263;
pub const ESYS_TR_RH_LOCKOUT: u32 = 266;
pub const ESYS_TR_RH_ENDORSEMENT: u32 = 267;
pub const ESYS_TR_RH_PLATFORM: u32 = 268;
pub const ESYS_TR_RH_PLATFORM_NV: u32 = 269;
pub const ESYS_TR_RH_AUTH_FIRST: u32 = 272;
pub const ESYS_TR_RH_ACT_FIRST: u32 = 288;
pub const ESYS_TR_RH_ACT_LAST: u32 = 303;
pub const _INTTYPES_H: u32 = 1;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2] = b"l\0";
pub const PRId8: &[u8; 2] = b"d\0";
pub const PRId16: &[u8; 2] = b"d\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRId64: &[u8; 3] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2] = b"d\0";
pub const PRIdLEAST16: &[u8; 2] = b"d\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIdLEAST64: &[u8; 3] = b"ld\0";
pub const PRIdFAST8: &[u8; 2] = b"d\0";
pub const PRIdFAST16: &[u8; 3] = b"ld\0";
pub const PRIdFAST32: &[u8; 3] = b"ld\0";
pub const PRIdFAST64: &[u8; 3] = b"ld\0";
pub const PRIi8: &[u8; 2] = b"i\0";
pub const PRIi16: &[u8; 2] = b"i\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIi64: &[u8; 3] = b"li\0";
pub const PRIiLEAST8: &[u8; 2] = b"i\0";
pub const PRIiLEAST16: &[u8; 2] = b"i\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIiLEAST64: &[u8; 3] = b"li\0";
pub const PRIiFAST8: &[u8; 2] = b"i\0";
pub const PRIiFAST16: &[u8; 3] = b"li\0";
pub const PRIiFAST32: &[u8; 3] = b"li\0";
pub const PRIiFAST64: &[u8; 3] = b"li\0";
pub const PRIo8: &[u8; 2] = b"o\0";
pub const PRIo16: &[u8; 2] = b"o\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIo64: &[u8; 3] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2] = b"o\0";
pub const PRIoLEAST16: &[u8; 2] = b"o\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIoLEAST64: &[u8; 3] = b"lo\0";
pub const PRIoFAST8: &[u8; 2] = b"o\0";
pub const PRIoFAST16: &[u8; 3] = b"lo\0";
pub const PRIoFAST32: &[u8; 3] = b"lo\0";
pub const PRIoFAST64: &[u8; 3] = b"lo\0";
pub const PRIu8: &[u8; 2] = b"u\0";
pub const PRIu16: &[u8; 2] = b"u\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIu64: &[u8; 3] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2] = b"u\0";
pub const PRIuLEAST16: &[u8; 2] = b"u\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIuLEAST64: &[u8; 3] = b"lu\0";
pub const PRIuFAST8: &[u8; 2] = b"u\0";
pub const PRIuFAST16: &[u8; 3] = b"lu\0";
pub const PRIuFAST32: &[u8; 3] = b"lu\0";
pub const PRIuFAST64: &[u8; 3] = b"lu\0";
pub const PRIx8: &[u8; 2] = b"x\0";
pub const PRIx16: &[u8; 2] = b"x\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIx64: &[u8; 3] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2] = b"x\0";
pub const PRIxLEAST16: &[u8; 2] = b"x\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIxLEAST64: &[u8; 3] = b"lx\0";
pub const PRIxFAST8: &[u8; 2] = b"x\0";
pub const PRIxFAST16: &[u8; 3] = b"lx\0";
pub const PRIxFAST32: &[u8; 3] = b"lx\0";
pub const PRIxFAST64: &[u8; 3] = b"lx\0";
pub const PRIX8: &[u8; 2] = b"X\0";
pub const PRIX16: &[u8; 2] = b"X\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRIX64: &[u8; 3] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2] = b"X\0";
pub const PRIXLEAST16: &[u8; 2] = b"X\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIXLEAST64: &[u8; 3] = b"lX\0";
pub const PRIXFAST8: &[u8; 2] = b"X\0";
pub const PRIXFAST16: &[u8; 3] = b"lX\0";
pub const PRIXFAST32: &[u8; 3] = b"lX\0";
pub const PRIXFAST64: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"ld\0";
pub const PRIiMAX: &[u8; 3] = b"li\0";
pub const PRIoMAX: &[u8; 3] = b"lo\0";
pub const PRIuMAX: &[u8; 3] = b"lu\0";
pub const PRIxMAX: &[u8; 3] = b"lx\0";
pub const PRIXMAX: &[u8; 3] = b"lX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNd64: &[u8; 3] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNdLEAST64: &[u8; 3] = b"ld\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3] = b"ld\0";
pub const SCNdFAST32: &[u8; 3] = b"ld\0";
pub const SCNdFAST64: &[u8; 3] = b"ld\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNi64: &[u8; 3] = b"li\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNiLEAST64: &[u8; 3] = b"li\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3] = b"li\0";
pub const SCNiFAST32: &[u8; 3] = b"li\0";
pub const SCNiFAST64: &[u8; 3] = b"li\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNu64: &[u8; 3] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNuLEAST64: &[u8; 3] = b"lu\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3] = b"lu\0";
pub const SCNuFAST32: &[u8; 3] = b"lu\0";
pub const SCNuFAST64: &[u8; 3] = b"lu\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNo64: &[u8; 3] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNoLEAST64: &[u8; 3] = b"lo\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNoFAST16: &[u8; 3] = b"lo\0";
pub const SCNoFAST32: &[u8; 3] = b"lo\0";
pub const SCNoFAST64: &[u8; 3] = b"lo\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNx64: &[u8; 3] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNxLEAST64: &[u8; 3] = b"lx\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3] = b"lx\0";
pub const SCNxFAST32: &[u8; 3] = b"lx\0";
pub const SCNxFAST64: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"ld\0";
pub const SCNiMAX: &[u8; 3] = b"li\0";
pub const SCNoMAX: &[u8; 3] = b"lo\0";
pub const SCNuMAX: &[u8; 3] = b"lu\0";
pub const SCNxMAX: &[u8; 3] = b"lx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type UINT8 = u8;
pub type BYTE = u8;
pub type INT8 = i8;
pub type BOOL = ::std::os::raw::c_int;
pub type UINT16 = u16;
pub type INT16 = i16;
pub type UINT32 = u32;
pub type INT32 = i32;
pub type UINT64 = u64;
pub type INT64 = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TSS2_ABI_VERSION {
    pub tssCreator: u32,
    pub tssFamily: u32,
    pub tssLevel: u32,
    pub tssVersion: u32,
}
#[test]
fn bindgen_test_layout_TSS2_ABI_VERSION() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2_ABI_VERSION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2_ABI_VERSION>(),
        16usize,
        concat!("Size of: ", stringify!(TSS2_ABI_VERSION))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2_ABI_VERSION>(),
        4usize,
        concat!("Alignment of ", stringify!(TSS2_ABI_VERSION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tssCreator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_ABI_VERSION),
            "::",
            stringify!(tssCreator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tssFamily) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_ABI_VERSION),
            "::",
            stringify!(tssFamily)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tssLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_ABI_VERSION),
            "::",
            stringify!(tssLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tssVersion) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_ABI_VERSION),
            "::",
            stringify!(tssVersion)
        )
    );
}
pub type TSS2_RC = u32;
pub type TPM2_ALG_ID = UINT16;
pub type TPM2_ECC_CURVE = UINT16;
pub type TPM2_CC = UINT32;
pub type TPM2_ALGORITHM_ID = UINT32;
pub type TPM2_MODIFIER_INDICATOR = UINT32;
pub type TPM2_AUTHORIZATION_SIZE = UINT32;
pub type TPM2_PARAMETER_SIZE = UINT32;
pub type TPM2_KEY_SIZE = UINT16;
pub type TPM2_KEY_BITS = UINT16;
pub type TPM2_SPEC = UINT32;
pub type TPM2_GENERATED = UINT32;
pub type TPM2_RC = UINT32;
pub type TPM2_CLOCK_ADJUST = INT8;
pub type TPM2_EO = UINT16;
pub type TPM2_ST = UINT16;
pub type TPM2_SU = UINT16;
pub type TPM2_SE = UINT8;
pub type TPM2_CAP = UINT32;
pub type TPM2_PT = UINT32;
pub type TPM2_PT_PCR = UINT32;
pub type TPM2_PS = UINT32;
pub type TPM2_HANDLE = UINT32;
pub type TPM2_HT = UINT8;
pub type TPM2_RH = TPM2_HANDLE;
pub type TPM2_HC = TPM2_HANDLE;
pub type TPMA_ALGORITHM = u32;
pub type TPMA_OBJECT = u32;
pub type TPMA_SESSION = UINT8;
pub type TPMA_LOCALITY = UINT8;
pub type TPMA_PERMANENT = u32;
pub type TPMA_STARTUP_CLEAR = u32;
pub type TPMA_MEMORY = u32;
pub type TPMA_CC = u32;
pub type TPMA_MODES = u32;
pub type TPMA_X509_KEY_USAGE = u32;
pub type TPMA_ACT = u32;
pub type TPMI_YES_NO = BYTE;
pub type TPMI_DH_OBJECT = TPM2_HANDLE;
pub type TPMI_DH_PERSISTENT = TPM2_HANDLE;
pub type TPMI_DH_ENTITY = TPM2_HANDLE;
pub type TPMI_DH_PCR = TPM2_HANDLE;
pub type TPMI_SH_AUTH_SESSION = TPM2_HANDLE;
pub type TPMI_SH_HMAC = TPM2_HANDLE;
pub type TPMI_SH_POLICY = TPM2_HANDLE;
pub type TPMI_DH_CONTEXT = TPM2_HANDLE;
pub type TPMI_DH_SAVED = TPM2_HANDLE;
pub type TPMI_RH_HIERARCHY = TPM2_HANDLE;
pub type TPMI_RH_ENABLES = TPM2_HANDLE;
pub type TPMI_RH_HIERARCHY_AUTH = TPM2_HANDLE;
pub type TPMI_RH_HIERARCHY_POLICY = TPM2_HANDLE;
pub type TPMI_RH_PLATFORM = TPM2_HANDLE;
pub type TPMI_RH_OWNER = TPM2_HANDLE;
pub type TPMI_RH_ENDORSEMENT = TPM2_HANDLE;
pub type TPMI_RH_PROVISION = TPM2_HANDLE;
pub type TPMI_RH_CLEAR = TPM2_HANDLE;
pub type TPMI_RH_NV_AUTH = TPM2_HANDLE;
pub type TPMI_RH_LOCKOUT = TPM2_HANDLE;
pub type TPMI_RH_NV_INDEX = TPM2_HANDLE;
pub type TPMI_RH_AC = TPM2_HANDLE;
pub type TPMI_RH_ACT = TPM2_HANDLE;
pub type TPMI_ALG_HASH = TPM2_ALG_ID;
pub type TPMI_ALG_ASYM = TPM2_ALG_ID;
pub type TPMI_ALG_SYM = TPM2_ALG_ID;
pub type TPMI_ALG_SYM_OBJECT = TPM2_ALG_ID;
pub type TPMI_ALG_SYM_MODE = TPM2_ALG_ID;
pub type TPMI_ALG_KDF = TPM2_ALG_ID;
pub type TPMI_ALG_SIG_SCHEME = TPM2_ALG_ID;
pub type TPMI_ECC_KEY_EXCHANGE = TPM2_ALG_ID;
pub type TPMI_ST_COMMAND_TAG = TPM2_ST;
pub type TPMI_ALG_MAC_SCHEME = TPM2_ALG_ID;
pub type TPMI_ALG_CIPHER_MODE = TPM2_ALG_ID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_EMPTY {
    pub empty: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_TPMS_EMPTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_EMPTY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_EMPTY>(),
        1usize,
        concat!("Size of: ", stringify!(TPMS_EMPTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_EMPTY>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMS_EMPTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).empty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_EMPTY),
            "::",
            stringify!(empty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    pub alg: TPM2_ALG_ID,
    pub attributes: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DESCRIPTION() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ALGORITHM_DESCRIPTION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ALGORITHM_DESCRIPTION>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_ALGORITHM_DESCRIPTION))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ALGORITHM_DESCRIPTION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ALGORITHM_DESCRIPTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DESCRIPTION),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DESCRIPTION),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_HA {
    pub sha1: [BYTE; 20usize],
    pub sha256: [BYTE; 32usize],
    pub sha384: [BYTE; 48usize],
    pub sha512: [BYTE; 64usize],
    pub sm3_256: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPMU_HA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_HA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_HA>(),
        64usize,
        concat!("Size of: ", stringify!(TPMU_HA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_HA>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMU_HA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha256)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha384)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sha512)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm3_256) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_HA),
            "::",
            stringify!(sm3_256)
        )
    );
}
impl Default for TPMU_HA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_HA {
    pub hashAlg: TPMI_ALG_HASH,
    pub digest: TPMU_HA,
}
#[test]
fn bindgen_test_layout_TPMT_HA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_HA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_HA>(),
        66usize,
        concat!("Size of: ", stringify!(TPMT_HA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_HA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_HA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashAlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_HA),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_HA),
            "::",
            stringify!(digest)
        )
    );
}
impl Default for TPMT_HA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_DIGEST {
    pub size: UINT16,
    pub buffer: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_DIGEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_DIGEST>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_DIGEST))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_DIGEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DIGEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DIGEST),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_DIGEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_DATA {
    pub size: UINT16,
    pub buffer: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_DATA>(),
        66usize,
        concat!("Size of: ", stringify!(TPM2B_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_DATA),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPM2B_NONCE = TPM2B_DIGEST;
pub type TPM2B_AUTH = TPM2B_DIGEST;
pub type TPM2B_OPERAND = TPM2B_DIGEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_EVENT {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_EVENT() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_EVENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_EVENT>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_EVENT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_EVENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_EVENT),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_EVENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_MAX_BUFFER {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_MAX_BUFFER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_MAX_BUFFER>(),
        1026usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_MAX_BUFFER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_BUFFER),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_MAX_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_MAX_NV_BUFFER {
    pub size: UINT16,
    pub buffer: [BYTE; 2048usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_NV_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_MAX_NV_BUFFER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_MAX_NV_BUFFER>(),
        2050usize,
        concat!("Size of: ", stringify!(TPM2B_MAX_NV_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_MAX_NV_BUFFER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_MAX_NV_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_MAX_NV_BUFFER),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_MAX_NV_BUFFER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPM2B_TIMEOUT = TPM2B_DIGEST;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPM2B_IV {
    pub size: UINT16,
    pub buffer: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_TPM2B_IV() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_IV> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_IV>(),
        18usize,
        concat!("Size of: ", stringify!(TPM2B_IV))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_IV>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_IV))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_IV),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_NAME {
    pub digest: TPMT_HA,
    pub handle: TPM2_HANDLE,
}
#[test]
fn bindgen_test_layout_TPMU_NAME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_NAME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_NAME>(),
        68usize,
        concat!("Size of: ", stringify!(TPMU_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_NAME>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_NAME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_NAME),
            "::",
            stringify!(digest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_NAME),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for TPMU_NAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_NAME {
    pub size: UINT16,
    pub name: [BYTE; 68usize],
}
#[test]
fn bindgen_test_layout_TPM2B_NAME() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_NAME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_NAME>(),
        70usize,
        concat!("Size of: ", stringify!(TPM2B_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_NAME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_NAME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NAME),
            "::",
            stringify!(name)
        )
    );
}
impl Default for TPM2B_NAME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_PCR_SELECT {
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_PCR_SELECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_PCR_SELECT>(),
        5usize,
        concat!("Size of: ", stringify!(TPMS_PCR_SELECT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_PCR_SELECT>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMS_PCR_SELECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofSelect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECT),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelect) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECT),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_PCR_SELECTION {
    pub hash: TPMI_ALG_HASH,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECTION() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_PCR_SELECTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_PCR_SELECTION>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_PCR_SELECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_PCR_SELECTION>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_PCR_SELECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofSelect) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelect) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_PCR_SELECTION),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMT_TK_CREATION {
    pub tag: TPM2_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_CREATION() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_TK_CREATION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_TK_CREATION>(),
        76usize,
        concat!("Size of: ", stringify!(TPMT_TK_CREATION))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_TK_CREATION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_CREATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_CREATION),
            "::",
            stringify!(digest)
        )
    );
}
impl Default for TPMT_TK_CREATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMT_TK_VERIFIED {
    pub tag: TPM2_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_VERIFIED() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_TK_VERIFIED> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_TK_VERIFIED>(),
        76usize,
        concat!("Size of: ", stringify!(TPMT_TK_VERIFIED))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_TK_VERIFIED>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_VERIFIED))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_VERIFIED),
            "::",
            stringify!(digest)
        )
    );
}
impl Default for TPMT_TK_VERIFIED {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMT_TK_AUTH {
    pub tag: TPM2_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_AUTH() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_TK_AUTH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_TK_AUTH>(),
        76usize,
        concat!("Size of: ", stringify!(TPMT_TK_AUTH))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_TK_AUTH>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_AUTH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_AUTH),
            "::",
            stringify!(digest)
        )
    );
}
impl Default for TPMT_TK_AUTH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMT_TK_HASHCHECK {
    pub tag: TPM2_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_HASHCHECK() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_TK_HASHCHECK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_TK_HASHCHECK>(),
        76usize,
        concat!("Size of: ", stringify!(TPMT_TK_HASHCHECK))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_TK_HASHCHECK>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_TK_HASHCHECK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_TK_HASHCHECK),
            "::",
            stringify!(digest)
        )
    );
}
impl Default for TPMT_TK_HASHCHECK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_ALG_PROPERTY {
    pub alg: TPM2_ALG_ID,
    pub algProperties: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALG_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ALG_PROPERTY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ALG_PROPERTY>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_ALG_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ALG_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ALG_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALG_PROPERTY),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algProperties) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALG_PROPERTY),
            "::",
            stringify!(algProperties)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_TAGGED_PROPERTY {
    pub property: TPM2_PT,
    pub value: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_TAGGED_PROPERTY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_TAGGED_PROPERTY>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_TAGGED_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PROPERTY),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PROPERTY),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_TAGGED_PCR_SELECT {
    pub tag: TPM2_PT_PCR,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 4usize],
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PCR_SELECT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_TAGGED_PCR_SELECT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_TAGGED_PCR_SELECT>(),
        12usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_PCR_SELECT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_TAGGED_PCR_SELECT>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_PCR_SELECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizeofSelect) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(sizeofSelect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelect) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_PCR_SELECT),
            "::",
            stringify!(pcrSelect)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_TAGGED_POLICY {
    pub handle: TPM2_HANDLE,
    pub policyHash: TPMT_HA,
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_TAGGED_POLICY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_TAGGED_POLICY>(),
        72usize,
        concat!("Size of: ", stringify!(TPMS_TAGGED_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_TAGGED_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_TAGGED_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_POLICY),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).policyHash) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TAGGED_POLICY),
            "::",
            stringify!(policyHash)
        )
    );
}
impl Default for TPMS_TAGGED_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_ACT_DATA {
    pub handle: TPM2_HANDLE,
    pub timeout: UINT32,
    pub attributes: TPMA_ACT,
}
#[test]
fn bindgen_test_layout_TPMS_ACT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ACT_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ACT_DATA>(),
        12usize,
        concat!("Size of: ", stringify!(TPMS_ACT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ACT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_ACT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ACT_DATA),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_CC {
    pub count: UINT32,
    pub commandCodes: [TPM2_CC; 256usize],
}
#[test]
fn bindgen_test_layout_TPML_CC() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_CC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_CC>(),
        1028usize,
        concat!("Size of: ", stringify!(TPML_CC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_CC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_CC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CC),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandCodes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CC),
            "::",
            stringify!(commandCodes)
        )
    );
}
impl Default for TPML_CC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_CCA {
    pub count: UINT32,
    pub commandAttributes: [TPMA_CC; 256usize],
}
#[test]
fn bindgen_test_layout_TPML_CCA() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_CCA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_CCA>(),
        1028usize,
        concat!("Size of: ", stringify!(TPML_CCA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_CCA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_CCA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CCA),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandAttributes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_CCA),
            "::",
            stringify!(commandAttributes)
        )
    );
}
impl Default for TPML_CCA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ALG {
    pub count: UINT32,
    pub algorithms: [TPM2_ALG_ID; 128usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_ALG> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_ALG>(),
        260usize,
        concat!("Size of: ", stringify!(TPML_ALG))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_ALG>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ALG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithms) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG),
            "::",
            stringify!(algorithms)
        )
    );
}
impl Default for TPML_ALG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_HANDLE {
    pub count: UINT32,
    pub handle: [TPM2_HANDLE; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_HANDLE() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_HANDLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_HANDLE>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_HANDLE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_HANDLE>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_HANDLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_HANDLE),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_HANDLE),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for TPML_HANDLE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_DIGEST {
    pub count: UINT32,
    pub digests: [TPM2B_DIGEST; 8usize],
}
#[test]
fn bindgen_test_layout_TPML_DIGEST() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_DIGEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_DIGEST>(),
        532usize,
        concat!("Size of: ", stringify!(TPML_DIGEST))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_DIGEST>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_DIGEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digests) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST),
            "::",
            stringify!(digests)
        )
    );
}
impl Default for TPML_DIGEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPML_DIGEST_VALUES {
    pub count: UINT32,
    pub digests: [TPMT_HA; 16usize],
}
#[test]
fn bindgen_test_layout_TPML_DIGEST_VALUES() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_DIGEST_VALUES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_DIGEST_VALUES>(),
        1060usize,
        concat!("Size of: ", stringify!(TPML_DIGEST_VALUES))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_DIGEST_VALUES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_DIGEST_VALUES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST_VALUES),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digests) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_DIGEST_VALUES),
            "::",
            stringify!(digests)
        )
    );
}
impl Default for TPML_DIGEST_VALUES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPML_PCR_SELECTION {
    pub count: UINT32,
    pub pcrSelections: [TPMS_PCR_SELECTION; 16usize],
}
#[test]
fn bindgen_test_layout_TPML_PCR_SELECTION() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_PCR_SELECTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_PCR_SELECTION>(),
        132usize,
        concat!("Size of: ", stringify!(TPML_PCR_SELECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_PCR_SELECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_PCR_SELECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_PCR_SELECTION),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelections) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_PCR_SELECTION),
            "::",
            stringify!(pcrSelections)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ALG_PROPERTY {
    pub count: UINT32,
    pub algProperties: [TPMS_ALG_PROPERTY; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_ALG_PROPERTY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_ALG_PROPERTY>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_ALG_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_ALG_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ALG_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algProperties) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ALG_PROPERTY),
            "::",
            stringify!(algProperties)
        )
    );
}
impl Default for TPML_ALG_PROPERTY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    pub count: UINT32,
    pub tpmProperty: [TPMS_TAGGED_PROPERTY; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_TPM_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_TAGGED_TPM_PROPERTY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_TAGGED_TPM_PROPERTY>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_TPM_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_TAGGED_TPM_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_TPM_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_TPM_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpmProperty) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_TPM_PROPERTY),
            "::",
            stringify!(tpmProperty)
        )
    );
}
impl Default for TPML_TAGGED_TPM_PROPERTY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    pub count: UINT32,
    pub pcrProperty: [TPMS_TAGGED_PCR_SELECT; 84usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_PCR_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_TAGGED_PCR_PROPERTY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_TAGGED_PCR_PROPERTY>(),
        1012usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_PCR_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_TAGGED_PCR_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_PCR_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_PCR_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrProperty) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_PCR_PROPERTY),
            "::",
            stringify!(pcrProperty)
        )
    );
}
impl Default for TPML_TAGGED_PCR_PROPERTY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ECC_CURVE {
    pub count: UINT32,
    pub eccCurves: [TPM2_ECC_CURVE; 508usize],
}
#[test]
fn bindgen_test_layout_TPML_ECC_CURVE() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_ECC_CURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_ECC_CURVE>(),
        1020usize,
        concat!("Size of: ", stringify!(TPML_ECC_CURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_ECC_CURVE>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ECC_CURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ECC_CURVE),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eccCurves) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ECC_CURVE),
            "::",
            stringify!(eccCurves)
        )
    );
}
impl Default for TPML_ECC_CURVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPML_TAGGED_POLICY {
    pub count: UINT32,
    pub policies: [TPMS_TAGGED_POLICY; 14usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_POLICY() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_TAGGED_POLICY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_TAGGED_POLICY>(),
        1012usize,
        concat!("Size of: ", stringify!(TPML_TAGGED_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_TAGGED_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_TAGGED_POLICY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_POLICY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).policies) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_TAGGED_POLICY),
            "::",
            stringify!(policies)
        )
    );
}
impl Default for TPML_TAGGED_POLICY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_ACT_DATA {
    pub count: UINT32,
    pub actData: [TPMS_ACT_DATA; 84usize],
}
#[test]
fn bindgen_test_layout_TPML_ACT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_ACT_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_ACT_DATA>(),
        1012usize,
        concat!("Size of: ", stringify!(TPML_ACT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_ACT_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_ACT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ACT_DATA),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_ACT_DATA),
            "::",
            stringify!(actData)
        )
    );
}
impl Default for TPML_ACT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_INTEL_PTT_PROPERTY {
    pub count: UINT32,
    pub property: [UINT32; 256usize],
}
#[test]
fn bindgen_test_layout_TPML_INTEL_PTT_PROPERTY() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_INTEL_PTT_PROPERTY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_INTEL_PTT_PROPERTY>(),
        1028usize,
        concat!("Size of: ", stringify!(TPML_INTEL_PTT_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_INTEL_PTT_PROPERTY>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_INTEL_PTT_PROPERTY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_INTEL_PTT_PROPERTY),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_INTEL_PTT_PROPERTY),
            "::",
            stringify!(property)
        )
    );
}
impl Default for TPML_INTEL_PTT_PROPERTY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_CAPABILITIES {
    pub algorithms: TPML_ALG_PROPERTY,
    pub handles: TPML_HANDLE,
    pub command: TPML_CCA,
    pub ppCommands: TPML_CC,
    pub auditCommands: TPML_CC,
    pub assignedPCR: TPML_PCR_SELECTION,
    pub tpmProperties: TPML_TAGGED_TPM_PROPERTY,
    pub pcrProperties: TPML_TAGGED_PCR_PROPERTY,
    pub eccCurves: TPML_ECC_CURVE,
    pub authPolicies: TPML_TAGGED_POLICY,
    pub actData: TPML_ACT_DATA,
    pub intelPttProperty: TPML_INTEL_PTT_PROPERTY,
}
#[test]
fn bindgen_test_layout_TPMU_CAPABILITIES() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_CAPABILITIES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_CAPABILITIES>(),
        1028usize,
        concat!("Size of: ", stringify!(TPMU_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_CAPABILITIES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(algorithms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(handles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppCommands) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(ppCommands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auditCommands) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(auditCommands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assignedPCR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(assignedPCR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpmProperties) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(tpmProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrProperties) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(pcrProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eccCurves) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(eccCurves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authPolicies) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(authPolicies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(actData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intelPttProperty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_CAPABILITIES),
            "::",
            stringify!(intelPttProperty)
        )
    );
}
impl Default for TPMU_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_CAPABILITY_DATA {
    pub capability: TPM2_CAP,
    pub data: TPMU_CAPABILITIES,
}
#[test]
fn bindgen_test_layout_TPMS_CAPABILITY_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CAPABILITY_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CAPABILITY_DATA>(),
        1032usize,
        concat!("Size of: ", stringify!(TPMS_CAPABILITY_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CAPABILITY_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_CAPABILITY_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CAPABILITY_DATA),
            "::",
            stringify!(capability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CAPABILITY_DATA),
            "::",
            stringify!(data)
        )
    );
}
impl Default for TPMS_CAPABILITY_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_CLOCK_INFO {
    pub clock: UINT64,
    pub resetCount: UINT32,
    pub restartCount: UINT32,
    pub safe: TPMI_YES_NO,
}
#[test]
fn bindgen_test_layout_TPMS_CLOCK_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CLOCK_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CLOCK_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(TPMS_CLOCK_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CLOCK_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_CLOCK_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(clock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resetCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(resetCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restartCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(restartCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).safe) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CLOCK_INFO),
            "::",
            stringify!(safe)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_TIME_INFO {
    pub time: UINT64,
    pub clockInfo: TPMS_CLOCK_INFO,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_TIME_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_TIME_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(TPMS_TIME_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_TIME_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_TIME_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_INFO),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_INFO),
            "::",
            stringify!(clockInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_TIME_ATTEST_INFO {
    pub time: TPMS_TIME_INFO,
    pub firmwareVersion: UINT64,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_ATTEST_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_TIME_ATTEST_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_TIME_ATTEST_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(TPMS_TIME_ATTEST_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_TIME_ATTEST_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_TIME_ATTEST_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_ATTEST_INFO),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareVersion) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_TIME_ATTEST_INFO),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CERTIFY_INFO {
    pub name: TPM2B_NAME,
    pub qualifiedName: TPM2B_NAME,
}
#[test]
fn bindgen_test_layout_TPMS_CERTIFY_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CERTIFY_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CERTIFY_INFO>(),
        140usize,
        concat!("Size of: ", stringify!(TPMS_CERTIFY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CERTIFY_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qualifiedName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CERTIFY_INFO),
            "::",
            stringify!(qualifiedName)
        )
    );
}
impl Default for TPMS_CERTIFY_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_QUOTE_INFO {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_QUOTE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_QUOTE_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_QUOTE_INFO>(),
        200usize,
        concat!("Size of: ", stringify!(TPMS_QUOTE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_QUOTE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_QUOTE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_QUOTE_INFO),
            "::",
            stringify!(pcrSelect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrDigest) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_QUOTE_INFO),
            "::",
            stringify!(pcrDigest)
        )
    );
}
impl Default for TPMS_QUOTE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    pub auditCounter: UINT64,
    pub digestAlg: TPM2_ALG_ID,
    pub auditDigest: TPM2B_DIGEST,
    pub commandDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_COMMAND_AUDIT_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_COMMAND_AUDIT_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_COMMAND_AUDIT_INFO>(),
        144usize,
        concat!("Size of: ", stringify!(TPMS_COMMAND_AUDIT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_COMMAND_AUDIT_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_COMMAND_AUDIT_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auditCounter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(auditCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digestAlg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(digestAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auditDigest) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(auditDigest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandDigest) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_COMMAND_AUDIT_INFO),
            "::",
            stringify!(commandDigest)
        )
    );
}
impl Default for TPMS_COMMAND_AUDIT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SESSION_AUDIT_INFO {
    pub exclusiveSession: TPMI_YES_NO,
    pub sessionDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_SESSION_AUDIT_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SESSION_AUDIT_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SESSION_AUDIT_INFO>(),
        68usize,
        concat!("Size of: ", stringify!(TPMS_SESSION_AUDIT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SESSION_AUDIT_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SESSION_AUDIT_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusiveSession) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SESSION_AUDIT_INFO),
            "::",
            stringify!(exclusiveSession)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionDigest) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SESSION_AUDIT_INFO),
            "::",
            stringify!(sessionDigest)
        )
    );
}
impl Default for TPMS_SESSION_AUDIT_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CREATION_INFO {
    pub objectName: TPM2B_NAME,
    pub creationHash: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CREATION_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CREATION_INFO>(),
        136usize,
        concat!("Size of: ", stringify!(TPMS_CREATION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CREATION_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CREATION_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_INFO),
            "::",
            stringify!(objectName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creationHash) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_INFO),
            "::",
            stringify!(creationHash)
        )
    );
}
impl Default for TPMS_CREATION_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_NV_CERTIFY_INFO {
    pub indexName: TPM2B_NAME,
    pub offset: UINT16,
    pub nvContents: TPM2B_MAX_NV_BUFFER,
}
#[test]
fn bindgen_test_layout_TPMS_NV_CERTIFY_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_NV_CERTIFY_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_NV_CERTIFY_INFO>(),
        2122usize,
        concat!("Size of: ", stringify!(TPMS_NV_CERTIFY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_NV_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_NV_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(indexName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvContents) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_CERTIFY_INFO),
            "::",
            stringify!(nvContents)
        )
    );
}
impl Default for TPMS_NV_CERTIFY_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_NV_DIGEST_CERTIFY_INFO {
    pub indexName: TPM2B_NAME,
    pub nvDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_NV_DIGEST_CERTIFY_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_NV_DIGEST_CERTIFY_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_NV_DIGEST_CERTIFY_INFO>(),
        136usize,
        concat!("Size of: ", stringify!(TPMS_NV_DIGEST_CERTIFY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_NV_DIGEST_CERTIFY_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_NV_DIGEST_CERTIFY_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).indexName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_DIGEST_CERTIFY_INFO),
            "::",
            stringify!(indexName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvDigest) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_DIGEST_CERTIFY_INFO),
            "::",
            stringify!(nvDigest)
        )
    );
}
impl Default for TPMS_NV_DIGEST_CERTIFY_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ST_ATTEST = TPM2_ST;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ATTEST {
    pub certify: TPMS_CERTIFY_INFO,
    pub creation: TPMS_CREATION_INFO,
    pub quote: TPMS_QUOTE_INFO,
    pub commandAudit: TPMS_COMMAND_AUDIT_INFO,
    pub sessionAudit: TPMS_SESSION_AUDIT_INFO,
    pub time: TPMS_TIME_ATTEST_INFO,
    pub nv: TPMS_NV_CERTIFY_INFO,
}
#[test]
fn bindgen_test_layout_TPMU_ATTEST() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_ATTEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_ATTEST>(),
        2128usize,
        concat!("Size of: ", stringify!(TPMU_ATTEST))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_ATTEST>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMU_ATTEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).certify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(certify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(creation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(quote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandAudit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(commandAudit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionAudit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(sessionAudit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ATTEST),
            "::",
            stringify!(nv)
        )
    );
}
impl Default for TPMU_ATTEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ATTEST {
    pub magic: TPM2_GENERATED,
    pub type_: TPMI_ST_ATTEST,
    pub qualifiedSigner: TPM2B_NAME,
    pub extraData: TPM2B_DATA,
    pub clockInfo: TPMS_CLOCK_INFO,
    pub firmwareVersion: UINT64,
    pub attested: TPMU_ATTEST,
}
#[test]
fn bindgen_test_layout_TPMS_ATTEST() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ATTEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ATTEST>(),
        2304usize,
        concat!("Size of: ", stringify!(TPMS_ATTEST))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ATTEST>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_ATTEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qualifiedSigner) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(qualifiedSigner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extraData) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(extraData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clockInfo) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(clockInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareVersion) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(firmwareVersion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attested) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ATTEST),
            "::",
            stringify!(attested)
        )
    );
}
impl Default for TPMS_ATTEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ATTEST {
    pub size: UINT16,
    pub attestationData: [BYTE; 2304usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ATTEST() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_ATTEST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_ATTEST>(),
        2306usize,
        concat!("Size of: ", stringify!(TPM2B_ATTEST))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_ATTEST>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ATTEST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attestationData) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ATTEST),
            "::",
            stringify!(attestationData)
        )
    );
}
impl Default for TPM2B_ATTEST {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_AUTH_COMMAND {
    pub sessionHandle: TPMI_SH_AUTH_SESSION,
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_COMMAND() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_AUTH_COMMAND> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_AUTH_COMMAND>(),
        140usize,
        concat!("Size of: ", stringify!(TPMS_AUTH_COMMAND))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_AUTH_COMMAND>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_AUTH_COMMAND))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(sessionHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionAttributes) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(sessionAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_COMMAND),
            "::",
            stringify!(hmac)
        )
    );
}
impl Default for TPMS_AUTH_COMMAND {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_AUTH_RESPONSE {
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_RESPONSE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_AUTH_RESPONSE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_AUTH_RESPONSE>(),
        134usize,
        concat!("Size of: ", stringify!(TPMS_AUTH_RESPONSE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_AUTH_RESPONSE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_AUTH_RESPONSE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sessionAttributes) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(sessionAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AUTH_RESPONSE),
            "::",
            stringify!(hmac)
        )
    );
}
impl Default for TPMS_AUTH_RESPONSE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_AES_KEY_BITS = TPM2_KEY_BITS;
pub type TPMI_SM4_KEY_BITS = TPM2_KEY_BITS;
pub type TPMI_CAMELLIA_KEY_BITS = TPM2_KEY_BITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SYM_KEY_BITS {
    pub aes: TPMI_AES_KEY_BITS,
    pub sm4: TPMI_SM4_KEY_BITS,
    pub camellia: TPMI_CAMELLIA_KEY_BITS,
    pub sym: TPM2_KEY_BITS,
    pub exclusiveOr: TPMI_ALG_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_KEY_BITS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SYM_KEY_BITS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SYM_KEY_BITS>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_SYM_KEY_BITS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SYM_KEY_BITS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SYM_KEY_BITS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(aes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(sm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).camellia) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(camellia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusiveOr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_KEY_BITS),
            "::",
            stringify!(exclusiveOr)
        )
    );
}
impl Default for TPMU_SYM_KEY_BITS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SYM_MODE {
    pub aes: TPMI_ALG_SYM_MODE,
    pub sm4: TPMI_ALG_SYM_MODE,
    pub camellia: TPMI_ALG_SYM_MODE,
    pub sym: TPMI_ALG_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_MODE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SYM_MODE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SYM_MODE>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_SYM_MODE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SYM_MODE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SYM_MODE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(aes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(sm4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).camellia) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(camellia)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SYM_MODE),
            "::",
            stringify!(sym)
        )
    );
}
impl Default for TPMU_SYM_MODE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SYM_DEF {
    pub algorithm: TPMI_ALG_SYM,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_SYM_DEF> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_SYM_DEF>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SYM_DEF))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_SYM_DEF>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SYM_DEF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyBits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for TPMT_SYM_DEF {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SYM_DEF_OBJECT {
    pub algorithm: TPMI_ALG_SYM_OBJECT,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF_OBJECT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_SYM_DEF_OBJECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_SYM_DEF_OBJECT>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SYM_DEF_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_SYM_DEF_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SYM_DEF_OBJECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyBits) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SYM_DEF_OBJECT),
            "::",
            stringify!(mode)
        )
    );
}
impl Default for TPMT_SYM_DEF_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPM2B_SYM_KEY {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SYM_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_SYM_KEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_SYM_KEY>(),
        34usize,
        concat!("Size of: ", stringify!(TPM2B_SYM_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_SYM_KEY>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SYM_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SYM_KEY),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_SYMCIPHER_PARMS {
    pub sym: TPMT_SYM_DEF_OBJECT,
}
#[test]
fn bindgen_test_layout_TPMS_SYMCIPHER_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SYMCIPHER_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SYMCIPHER_PARMS>(),
        6usize,
        concat!("Size of: ", stringify!(TPMS_SYMCIPHER_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SYMCIPHER_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SYMCIPHER_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SYMCIPHER_PARMS),
            "::",
            stringify!(sym)
        )
    );
}
impl Default for TPMS_SYMCIPHER_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SENSITIVE_DATA {
    pub size: UINT16,
    pub buffer: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_SENSITIVE_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_SENSITIVE_DATA>(),
        258usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_SENSITIVE_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_DATA),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_SENSITIVE_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SENSITIVE_CREATE {
    pub userAuth: TPM2B_AUTH,
    pub data: TPM2B_SENSITIVE_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_SENSITIVE_CREATE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SENSITIVE_CREATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SENSITIVE_CREATE>(),
        324usize,
        concat!("Size of: ", stringify!(TPMS_SENSITIVE_CREATE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SENSITIVE_CREATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SENSITIVE_CREATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).userAuth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SENSITIVE_CREATE),
            "::",
            stringify!(userAuth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SENSITIVE_CREATE),
            "::",
            stringify!(data)
        )
    );
}
impl Default for TPMS_SENSITIVE_CREATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_SENSITIVE_CREATE {
    pub size: UINT16,
    pub sensitive: TPMS_SENSITIVE_CREATE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_CREATE() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_SENSITIVE_CREATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_SENSITIVE_CREATE>(),
        326usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE_CREATE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_SENSITIVE_CREATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE_CREATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_CREATE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensitive) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE_CREATE),
            "::",
            stringify!(sensitive)
        )
    );
}
impl Default for TPM2B_SENSITIVE_CREATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_SCHEME_HASH {
    pub hashAlg: TPMI_ALG_HASH,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SCHEME_HASH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SCHEME_HASH>(),
        2usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SCHEME_HASH>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashAlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_HASH),
            "::",
            stringify!(hashAlg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_SCHEME_ECDAA {
    pub hashAlg: TPMI_ALG_HASH,
    pub count: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_ECDAA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SCHEME_ECDAA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SCHEME_ECDAA>(),
        4usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_ECDAA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SCHEME_ECDAA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_ECDAA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashAlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_ECDAA),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_ECDAA),
            "::",
            stringify!(count)
        )
    );
}
pub type TPMI_ALG_KEYEDHASH_SCHEME = TPM2_ALG_ID;
pub type TPMS_SCHEME_HMAC = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_SCHEME_XOR {
    pub hashAlg: TPMI_ALG_HASH,
    pub kdf: TPMI_ALG_KDF,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_XOR() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SCHEME_XOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SCHEME_XOR>(),
        4usize,
        concat!("Size of: ", stringify!(TPMS_SCHEME_XOR))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SCHEME_XOR>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SCHEME_XOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashAlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_XOR),
            "::",
            stringify!(hashAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SCHEME_XOR),
            "::",
            stringify!(kdf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SCHEME_KEYEDHASH {
    pub hmac: TPMS_SCHEME_HMAC,
    pub exclusiveOr: TPMS_SCHEME_XOR,
}
#[test]
fn bindgen_test_layout_TPMU_SCHEME_KEYEDHASH() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SCHEME_KEYEDHASH> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SCHEME_KEYEDHASH>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_SCHEME_KEYEDHASH))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SCHEME_KEYEDHASH>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SCHEME_KEYEDHASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SCHEME_KEYEDHASH),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusiveOr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SCHEME_KEYEDHASH),
            "::",
            stringify!(exclusiveOr)
        )
    );
}
impl Default for TPMU_SCHEME_KEYEDHASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_KEYEDHASH_SCHEME {
    pub scheme: TPMI_ALG_KEYEDHASH_SCHEME,
    pub details: TPMU_SCHEME_KEYEDHASH,
}
#[test]
fn bindgen_test_layout_TPMT_KEYEDHASH_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_KEYEDHASH_SCHEME> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_KEYEDHASH_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_KEYEDHASH_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_KEYEDHASH_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_KEYEDHASH_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KEYEDHASH_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KEYEDHASH_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_KEYEDHASH_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMS_SIG_SCHEME_RSASSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_RSAPSS = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_SM2 = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECSCHNORR = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDAA = TPMS_SCHEME_ECDAA;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SIG_SCHEME {
    pub rsassa: TPMS_SIG_SCHEME_RSASSA,
    pub rsapss: TPMS_SIG_SCHEME_RSAPSS,
    pub ecdsa: TPMS_SIG_SCHEME_ECDSA,
    pub ecdaa: TPMS_SIG_SCHEME_ECDAA,
    pub sm2: TPMS_SIG_SCHEME_SM2,
    pub ecschnorr: TPMS_SIG_SCHEME_ECSCHNORR,
    pub hmac: TPMS_SCHEME_HMAC,
    pub any: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SIG_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SIG_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SIG_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_SIG_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SIG_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SIG_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsassa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsapss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdaa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(sm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecschnorr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIG_SCHEME),
            "::",
            stringify!(any)
        )
    );
}
impl Default for TPMU_SIG_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SIG_SCHEME {
    pub scheme: TPMI_ALG_SIG_SCHEME,
    pub details: TPMU_SIG_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_SIG_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_SIG_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_SIG_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_SIG_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_SIG_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SIG_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIG_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIG_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_SIG_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMS_ENC_SCHEME_OAEP = TPMS_SCHEME_HASH;
pub type TPMS_ENC_SCHEME_RSAES = TPMS_EMPTY;
pub type TPMS_KEY_SCHEME_ECDH = TPMS_SCHEME_HASH;
pub type TPMS_KEY_SCHEME_ECMQV = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_MGF1 = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF1_SP800_56A = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF2 = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF1_SP800_108 = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_KDF_SCHEME {
    pub mgf1: TPMS_SCHEME_MGF1,
    pub kdf1_sp800_56a: TPMS_SCHEME_KDF1_SP800_56A,
    pub kdf2: TPMS_SCHEME_KDF2,
    pub kdf1_sp800_108: TPMS_SCHEME_KDF1_SP800_108,
}
#[test]
fn bindgen_test_layout_TPMU_KDF_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_KDF_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_KDF_SCHEME>(),
        2usize,
        concat!("Size of: ", stringify!(TPMU_KDF_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_KDF_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_KDF_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mgf1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(mgf1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf1_sp800_56a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf1_sp800_56a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf1_sp800_108) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_KDF_SCHEME),
            "::",
            stringify!(kdf1_sp800_108)
        )
    );
}
impl Default for TPMU_KDF_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_KDF_SCHEME {
    pub scheme: TPMI_ALG_KDF,
    pub details: TPMU_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_KDF_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_KDF_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_KDF_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMT_KDF_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_KDF_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_KDF_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KDF_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_KDF_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_KDF_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ALG_ASYM_SCHEME = TPM2_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ASYM_SCHEME {
    pub ecdh: TPMS_KEY_SCHEME_ECDH,
    pub ecmqv: TPMS_KEY_SCHEME_ECMQV,
    pub rsassa: TPMS_SIG_SCHEME_RSASSA,
    pub rsapss: TPMS_SIG_SCHEME_RSAPSS,
    pub ecdsa: TPMS_SIG_SCHEME_ECDSA,
    pub ecdaa: TPMS_SIG_SCHEME_ECDAA,
    pub sm2: TPMS_SIG_SCHEME_SM2,
    pub ecschnorr: TPMS_SIG_SCHEME_ECSCHNORR,
    pub rsaes: TPMS_ENC_SCHEME_RSAES,
    pub oaep: TPMS_ENC_SCHEME_OAEP,
    pub anySig: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_ASYM_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_ASYM_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_ASYM_SCHEME>(),
        4usize,
        concat!("Size of: ", stringify!(TPMU_ASYM_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_ASYM_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_ASYM_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdh) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecmqv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecmqv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsassa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsapss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdaa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(sm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecschnorr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsaes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(rsaes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oaep) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(oaep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).anySig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ASYM_SCHEME),
            "::",
            stringify!(anySig)
        )
    );
}
impl Default for TPMU_ASYM_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_ASYM_SCHEME {
    pub scheme: TPMI_ALG_ASYM_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ASYM_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_ASYM_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_ASYM_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_ASYM_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_ASYM_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_ASYM_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ASYM_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ASYM_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_ASYM_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ALG_RSA_SCHEME = TPM2_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_RSA_SCHEME {
    pub scheme: TPMI_ALG_RSA_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_RSA_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_RSA_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_RSA_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_RSA_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_RSA_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_RSA_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ALG_RSA_DECRYPT = TPM2_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_RSA_DECRYPT {
    pub scheme: TPMI_ALG_RSA_DECRYPT,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_DECRYPT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_RSA_DECRYPT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_RSA_DECRYPT>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_RSA_DECRYPT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_RSA_DECRYPT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_RSA_DECRYPT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_DECRYPT),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_RSA_DECRYPT),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_RSA_DECRYPT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PUBLIC_KEY_RSA {
    pub size: UINT16,
    pub buffer: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC_KEY_RSA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_PUBLIC_KEY_RSA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_PUBLIC_KEY_RSA>(),
        514usize,
        concat!("Size of: ", stringify!(TPM2B_PUBLIC_KEY_RSA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_PUBLIC_KEY_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PUBLIC_KEY_RSA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC_KEY_RSA),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_PUBLIC_KEY_RSA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_RSA_KEY_BITS = TPM2_KEY_BITS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE_KEY_RSA {
    pub size: UINT16,
    pub buffer: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_KEY_RSA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_PRIVATE_KEY_RSA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_PRIVATE_KEY_RSA>(),
        258usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE_KEY_RSA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_PRIVATE_KEY_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE_KEY_RSA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_KEY_RSA),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_PRIVATE_KEY_RSA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ECC_PARAMETER {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_PARAMETER() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_ECC_PARAMETER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_ECC_PARAMETER>(),
        130usize,
        concat!("Size of: ", stringify!(TPM2B_ECC_PARAMETER))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_ECC_PARAMETER>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ECC_PARAMETER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_PARAMETER),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_ECC_PARAMETER {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_ECC_POINT {
    pub x: TPM2B_ECC_PARAMETER,
    pub y: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_POINT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ECC_POINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ECC_POINT>(),
        260usize,
        concat!("Size of: ", stringify!(TPMS_ECC_POINT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ECC_POINT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ECC_POINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_POINT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_POINT),
            "::",
            stringify!(y)
        )
    );
}
impl Default for TPMS_ECC_POINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ECC_POINT {
    pub size: UINT16,
    pub point: TPMS_ECC_POINT,
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_POINT() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_ECC_POINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_ECC_POINT>(),
        262usize,
        concat!("Size of: ", stringify!(TPM2B_ECC_POINT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_ECC_POINT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ECC_POINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_POINT),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ECC_POINT),
            "::",
            stringify!(point)
        )
    );
}
impl Default for TPM2B_ECC_POINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ALG_ECC_SCHEME = TPM2_ALG_ID;
pub type TPMI_ECC_CURVE = TPM2_ECC_CURVE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_ECC_SCHEME {
    pub scheme: TPMI_ALG_ECC_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ECC_SCHEME() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_ECC_SCHEME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_ECC_SCHEME>(),
        6usize,
        concat!("Size of: ", stringify!(TPMT_ECC_SCHEME))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_ECC_SCHEME>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_ECC_SCHEME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ECC_SCHEME),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).details) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_ECC_SCHEME),
            "::",
            stringify!(details)
        )
    );
}
impl Default for TPMT_ECC_SCHEME {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    pub curveID: TPM2_ECC_CURVE,
    pub keySize: UINT16,
    pub kdf: TPMT_KDF_SCHEME,
    pub sign: TPMT_ECC_SCHEME,
    pub p: TPM2B_ECC_PARAMETER,
    pub a: TPM2B_ECC_PARAMETER,
    pub b: TPM2B_ECC_PARAMETER,
    pub gX: TPM2B_ECC_PARAMETER,
    pub gY: TPM2B_ECC_PARAMETER,
    pub n: TPM2B_ECC_PARAMETER,
    pub h: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DETAIL_ECC() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ALGORITHM_DETAIL_ECC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ALGORITHM_DETAIL_ECC>(),
        924usize,
        concat!("Size of: ", stringify!(TPMS_ALGORITHM_DETAIL_ECC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ALGORITHM_DETAIL_ECC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ALGORITHM_DETAIL_ECC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curveID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(curveID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keySize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(keySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(kdf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sign) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        274usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gX) as usize - ptr as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(gX)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gY) as usize - ptr as usize },
        534usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(gY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        794usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ALGORITHM_DETAIL_ECC),
            "::",
            stringify!(h)
        )
    );
}
impl Default for TPMS_ALGORITHM_DETAIL_ECC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SIGNATURE_RSA {
    pub hash: TPMI_ALG_HASH,
    pub sig: TPM2B_PUBLIC_KEY_RSA,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_RSA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SIGNATURE_RSA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SIGNATURE_RSA>(),
        516usize,
        concat!("Size of: ", stringify!(TPMS_SIGNATURE_RSA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SIGNATURE_RSA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SIGNATURE_RSA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_RSA),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_RSA),
            "::",
            stringify!(sig)
        )
    );
}
impl Default for TPMS_SIGNATURE_RSA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMS_SIGNATURE_RSASSA = TPMS_SIGNATURE_RSA;
pub type TPMS_SIGNATURE_RSAPSS = TPMS_SIGNATURE_RSA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_SIGNATURE_ECC {
    pub hash: TPMI_ALG_HASH,
    pub signatureR: TPM2B_ECC_PARAMETER,
    pub signatureS: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_ECC() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_SIGNATURE_ECC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_SIGNATURE_ECC>(),
        262usize,
        concat!("Size of: ", stringify!(TPMS_SIGNATURE_ECC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_SIGNATURE_ECC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_SIGNATURE_ECC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signatureR) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(signatureR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signatureS) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_SIGNATURE_ECC),
            "::",
            stringify!(signatureS)
        )
    );
}
impl Default for TPMS_SIGNATURE_ECC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMS_SIGNATURE_ECDSA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECDAA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_SM2 = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECSCHNORR = TPMS_SIGNATURE_ECC;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SIGNATURE {
    pub rsassa: TPMS_SIGNATURE_RSASSA,
    pub rsapss: TPMS_SIGNATURE_RSAPSS,
    pub ecdsa: TPMS_SIGNATURE_ECDSA,
    pub ecdaa: TPMS_SIGNATURE_ECDAA,
    pub sm2: TPMS_SIGNATURE_SM2,
    pub ecschnorr: TPMS_SIGNATURE_ECSCHNORR,
    pub hmac: TPMT_HA,
    pub any: TPMS_SCHEME_HASH,
}
#[test]
fn bindgen_test_layout_TPMU_SIGNATURE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SIGNATURE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SIGNATURE>(),
        516usize,
        concat!("Size of: ", stringify!(TPMU_SIGNATURE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SIGNATURE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SIGNATURE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsassa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(rsassa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsapss) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(rsapss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecdsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecdaa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecdaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sm2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(sm2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecschnorr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(ecschnorr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hmac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(hmac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SIGNATURE),
            "::",
            stringify!(any)
        )
    );
}
impl Default for TPMU_SIGNATURE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SIGNATURE {
    pub sigAlg: TPMI_ALG_SIG_SCHEME,
    pub signature: TPMU_SIGNATURE,
}
#[test]
fn bindgen_test_layout_TPMT_SIGNATURE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_SIGNATURE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_SIGNATURE>(),
        518usize,
        concat!("Size of: ", stringify!(TPMT_SIGNATURE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_SIGNATURE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SIGNATURE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigAlg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIGNATURE),
            "::",
            stringify!(sigAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SIGNATURE),
            "::",
            stringify!(signature)
        )
    );
}
impl Default for TPMT_SIGNATURE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_ENCRYPTED_SECRET {
    pub ecc: [BYTE; 260usize],
    pub rsa: [BYTE; 512usize],
    pub symmetric: [BYTE; 66usize],
    pub keyedHash: [BYTE; 66usize],
}
#[test]
fn bindgen_test_layout_TPMU_ENCRYPTED_SECRET() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_ENCRYPTED_SECRET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_ENCRYPTED_SECRET>(),
        512usize,
        concat!("Size of: ", stringify!(TPMU_ENCRYPTED_SECRET))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_ENCRYPTED_SECRET>(),
        1usize,
        concat!("Alignment of ", stringify!(TPMU_ENCRYPTED_SECRET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symmetric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_ENCRYPTED_SECRET),
            "::",
            stringify!(keyedHash)
        )
    );
}
impl Default for TPMU_ENCRYPTED_SECRET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ENCRYPTED_SECRET {
    pub size: UINT16,
    pub secret: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ENCRYPTED_SECRET() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_ENCRYPTED_SECRET> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_ENCRYPTED_SECRET>(),
        514usize,
        concat!("Size of: ", stringify!(TPM2B_ENCRYPTED_SECRET))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_ENCRYPTED_SECRET>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ENCRYPTED_SECRET))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secret) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ENCRYPTED_SECRET),
            "::",
            stringify!(secret)
        )
    );
}
impl Default for TPM2B_ENCRYPTED_SECRET {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPMI_ALG_PUBLIC = TPM2_ALG_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_PUBLIC_ID {
    pub keyedHash: TPM2B_DIGEST,
    pub sym: TPM2B_DIGEST,
    pub rsa: TPM2B_PUBLIC_KEY_RSA,
    pub ecc: TPMS_ECC_POINT,
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_ID() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_PUBLIC_ID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_PUBLIC_ID>(),
        514usize,
        concat!("Size of: ", stringify!(TPMU_PUBLIC_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_PUBLIC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_PUBLIC_ID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(keyedHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_ID),
            "::",
            stringify!(ecc)
        )
    );
}
impl Default for TPMU_PUBLIC_ID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_KEYEDHASH_PARMS {
    pub scheme: TPMT_KEYEDHASH_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_KEYEDHASH_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_KEYEDHASH_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_KEYEDHASH_PARMS>(),
        6usize,
        concat!("Size of: ", stringify!(TPMS_KEYEDHASH_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_KEYEDHASH_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_KEYEDHASH_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_KEYEDHASH_PARMS),
            "::",
            stringify!(scheme)
        )
    );
}
impl Default for TPMS_KEYEDHASH_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ASYM_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ASYM_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ASYM_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ASYM_PARMS>(),
        12usize,
        concat!("Size of: ", stringify!(TPMS_ASYM_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ASYM_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ASYM_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symmetric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ASYM_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ASYM_PARMS),
            "::",
            stringify!(scheme)
        )
    );
}
impl Default for TPMS_ASYM_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_RSA_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_RSA_SCHEME,
    pub keyBits: TPMI_RSA_KEY_BITS,
    pub exponent: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_RSA_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_RSA_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_RSA_PARMS>(),
        20usize,
        concat!("Size of: ", stringify!(TPMS_RSA_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_RSA_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_RSA_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symmetric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(keyBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_RSA_PARMS),
            "::",
            stringify!(exponent)
        )
    );
}
impl Default for TPMS_RSA_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMS_ECC_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ECC_SCHEME,
    pub curveID: TPMI_ECC_CURVE,
    pub kdf: TPMT_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ECC_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ECC_PARMS>(),
        18usize,
        concat!("Size of: ", stringify!(TPMS_ECC_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ECC_PARMS>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ECC_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symmetric) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(symmetric)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).curveID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(curveID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kdf) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ECC_PARMS),
            "::",
            stringify!(kdf)
        )
    );
}
impl Default for TPMS_ECC_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_PUBLIC_PARMS {
    pub keyedHashDetail: TPMS_KEYEDHASH_PARMS,
    pub symDetail: TPMS_SYMCIPHER_PARMS,
    pub rsaDetail: TPMS_RSA_PARMS,
    pub eccDetail: TPMS_ECC_PARMS,
    pub asymDetail: TPMS_ASYM_PARMS,
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_PUBLIC_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_PUBLIC_PARMS>(),
        20usize,
        concat!("Size of: ", stringify!(TPMU_PUBLIC_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_PUBLIC_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMU_PUBLIC_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyedHashDetail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(keyedHashDetail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symDetail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(symDetail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsaDetail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(rsaDetail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eccDetail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(eccDetail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asymDetail) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_PUBLIC_PARMS),
            "::",
            stringify!(asymDetail)
        )
    );
}
impl Default for TPMU_PUBLIC_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_PUBLIC_PARMS {
    pub type_: TPMI_ALG_PUBLIC,
    pub parameters: TPMU_PUBLIC_PARMS,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC_PARMS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_PUBLIC_PARMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_PUBLIC_PARMS>(),
        24usize,
        concat!("Size of: ", stringify!(TPMT_PUBLIC_PARMS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_PUBLIC_PARMS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_PUBLIC_PARMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC_PARMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC_PARMS),
            "::",
            stringify!(parameters)
        )
    );
}
impl Default for TPMT_PUBLIC_PARMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_PUBLIC {
    pub type_: TPMI_ALG_PUBLIC,
    pub nameAlg: TPMI_ALG_HASH,
    pub objectAttributes: TPMA_OBJECT,
    pub authPolicy: TPM2B_DIGEST,
    pub parameters: TPMU_PUBLIC_PARMS,
    pub unique: TPMU_PUBLIC_ID,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_PUBLIC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_PUBLIC>(),
        612usize,
        concat!("Size of: ", stringify!(TPMT_PUBLIC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMT_PUBLIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nameAlg) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(nameAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectAttributes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(objectAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authPolicy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(authPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unique) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_PUBLIC),
            "::",
            stringify!(unique)
        )
    );
}
impl Default for TPMT_PUBLIC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_PUBLIC {
    pub size: UINT16,
    pub publicArea: TPMT_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_PUBLIC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_PUBLIC>(),
        616usize,
        concat!("Size of: ", stringify!(TPM2B_PUBLIC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_PUBLIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).publicArea) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PUBLIC),
            "::",
            stringify!(publicArea)
        )
    );
}
impl Default for TPM2B_PUBLIC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_TEMPLATE {
    pub size: UINT16,
    pub buffer: [BYTE; 612usize],
}
#[test]
fn bindgen_test_layout_TPM2B_TEMPLATE() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_TEMPLATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_TEMPLATE>(),
        614usize,
        concat!("Size of: ", stringify!(TPM2B_TEMPLATE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_TEMPLATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_TEMPLATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_TEMPLATE),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_TEMPLATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub size: UINT16,
    pub buffer: [BYTE; 1280usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_VENDOR_SPECIFIC() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_PRIVATE_VENDOR_SPECIFIC> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>(),
        1282usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE_VENDOR_SPECIFIC),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TPMU_SENSITIVE_COMPOSITE {
    pub rsa: TPM2B_PRIVATE_KEY_RSA,
    pub ecc: TPM2B_ECC_PARAMETER,
    pub bits: TPM2B_SENSITIVE_DATA,
    pub sym: TPM2B_SYM_KEY,
    pub any: TPM2B_PRIVATE_VENDOR_SPECIFIC,
}
#[test]
fn bindgen_test_layout_TPMU_SENSITIVE_COMPOSITE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMU_SENSITIVE_COMPOSITE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMU_SENSITIVE_COMPOSITE>(),
        1282usize,
        concat!("Size of: ", stringify!(TPMU_SENSITIVE_COMPOSITE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMU_SENSITIVE_COMPOSITE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMU_SENSITIVE_COMPOSITE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(ecc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).any) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMU_SENSITIVE_COMPOSITE),
            "::",
            stringify!(any)
        )
    );
}
impl Default for TPMU_SENSITIVE_COMPOSITE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPMT_SENSITIVE {
    pub sensitiveType: TPMI_ALG_PUBLIC,
    pub authValue: TPM2B_AUTH,
    pub seedValue: TPM2B_DIGEST,
    pub sensitive: TPMU_SENSITIVE_COMPOSITE,
}
#[test]
fn bindgen_test_layout_TPMT_SENSITIVE() {
    const UNINIT: ::std::mem::MaybeUninit<TPMT_SENSITIVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMT_SENSITIVE>(),
        1416usize,
        concat!("Size of: ", stringify!(TPMT_SENSITIVE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMT_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMT_SENSITIVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensitiveType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(sensitiveType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authValue) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(authValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seedValue) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(seedValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensitive) as usize - ptr as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMT_SENSITIVE),
            "::",
            stringify!(sensitive)
        )
    );
}
impl Default for TPMT_SENSITIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TPM2B_SENSITIVE {
    pub size: UINT16,
    pub sensitiveArea: TPMT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_SENSITIVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_SENSITIVE>(),
        1418usize,
        concat!("Size of: ", stringify!(TPM2B_SENSITIVE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_SENSITIVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensitiveArea) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_SENSITIVE),
            "::",
            stringify!(sensitiveArea)
        )
    );
}
impl Default for TPM2B_SENSITIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PRIVATE {
    pub integrityOuter: TPM2B_DIGEST,
    pub integrityInner: TPM2B_DIGEST,
    pub sensitive: TPM2B_SENSITIVE,
}
#[test]
fn bindgen_test_layout__PRIVATE() {
    const UNINIT: ::std::mem::MaybeUninit<_PRIVATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_PRIVATE>(),
        1550usize,
        concat!("Size of: ", stringify!(_PRIVATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_PRIVATE>(),
        2usize,
        concat!("Alignment of ", stringify!(_PRIVATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrityOuter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(integrityOuter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrityInner) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(integrityInner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sensitive) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVATE),
            "::",
            stringify!(sensitive)
        )
    );
}
impl Default for _PRIVATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_PRIVATE {
    pub size: UINT16,
    pub buffer: [BYTE; 1550usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_PRIVATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_PRIVATE>(),
        1552usize,
        concat!("Size of: ", stringify!(TPM2B_PRIVATE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_PRIVATE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_PRIVATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_PRIVATE),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_PRIVATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_ID_OBJECT {
    pub integrityHMAC: TPM2B_DIGEST,
    pub encIdentity: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_ID_OBJECT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_ID_OBJECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_ID_OBJECT>(),
        132usize,
        concat!("Size of: ", stringify!(TPMS_ID_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_ID_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_ID_OBJECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrityHMAC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ID_OBJECT),
            "::",
            stringify!(integrityHMAC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encIdentity) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_ID_OBJECT),
            "::",
            stringify!(encIdentity)
        )
    );
}
impl Default for TPMS_ID_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_ID_OBJECT {
    pub size: UINT16,
    pub credential: [BYTE; 132usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ID_OBJECT() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_ID_OBJECT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_ID_OBJECT>(),
        134usize,
        concat!("Size of: ", stringify!(TPM2B_ID_OBJECT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_ID_OBJECT>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_ID_OBJECT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).credential) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_ID_OBJECT),
            "::",
            stringify!(credential)
        )
    );
}
impl Default for TPM2B_ID_OBJECT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPM2_NV_INDEX = u32;
pub type TPM2_NT = UINT8;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    pub pinCount: UINT32,
    pub pinLimit: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PIN_COUNTER_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_NV_PIN_COUNTER_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pinCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS),
            "::",
            stringify!(pinCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pinLimit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PIN_COUNTER_PARAMETERS),
            "::",
            stringify!(pinLimit)
        )
    );
}
pub type TPMA_NV = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_NV_PUBLIC {
    pub nvIndex: TPMI_RH_NV_INDEX,
    pub nameAlg: TPMI_ALG_HASH,
    pub attributes: TPMA_NV,
    pub authPolicy: TPM2B_DIGEST,
    pub dataSize: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PUBLIC() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_NV_PUBLIC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_NV_PUBLIC>(),
        80usize,
        concat!("Size of: ", stringify!(TPMS_NV_PUBLIC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_NV_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_NV_PUBLIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(nvIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nameAlg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(nameAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authPolicy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(authPolicy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_NV_PUBLIC),
            "::",
            stringify!(dataSize)
        )
    );
}
impl Default for TPMS_NV_PUBLIC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_NV_PUBLIC {
    pub size: UINT16,
    pub nvPublic: TPMS_NV_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_NV_PUBLIC() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_NV_PUBLIC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_NV_PUBLIC>(),
        84usize,
        concat!("Size of: ", stringify!(TPM2B_NV_PUBLIC))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_NV_PUBLIC>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_NV_PUBLIC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NV_PUBLIC),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvPublic) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_NV_PUBLIC),
            "::",
            stringify!(nvPublic)
        )
    );
}
impl Default for TPM2B_NV_PUBLIC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_CONTEXT_SENSITIVE {
    pub size: UINT16,
    pub buffer: [BYTE; 5120usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_SENSITIVE() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_CONTEXT_SENSITIVE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_CONTEXT_SENSITIVE>(),
        5122usize,
        concat!("Size of: ", stringify!(TPM2B_CONTEXT_SENSITIVE))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_CONTEXT_SENSITIVE>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_CONTEXT_SENSITIVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_SENSITIVE),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_CONTEXT_SENSITIVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CONTEXT_DATA {
    pub integrity: TPM2B_DIGEST,
    pub encrypted: TPM2B_CONTEXT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CONTEXT_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CONTEXT_DATA>(),
        5188usize,
        concat!("Size of: ", stringify!(TPMS_CONTEXT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CONTEXT_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPMS_CONTEXT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integrity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT_DATA),
            "::",
            stringify!(integrity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypted) as usize - ptr as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT_DATA),
            "::",
            stringify!(encrypted)
        )
    );
}
impl Default for TPMS_CONTEXT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_CONTEXT_DATA {
    pub size: UINT16,
    pub buffer: [BYTE; 5188usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_CONTEXT_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_CONTEXT_DATA>(),
        5190usize,
        concat!("Size of: ", stringify!(TPM2B_CONTEXT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_CONTEXT_DATA>(),
        2usize,
        concat!("Alignment of ", stringify!(TPM2B_CONTEXT_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CONTEXT_DATA),
            "::",
            stringify!(buffer)
        )
    );
}
impl Default for TPM2B_CONTEXT_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CONTEXT {
    pub sequence: UINT64,
    pub savedHandle: TPMI_DH_CONTEXT,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub contextBlob: TPM2B_CONTEXT_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CONTEXT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CONTEXT>(),
        5208usize,
        concat!("Size of: ", stringify!(TPMS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(TPMS_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).savedHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(savedHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hierarchy) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(hierarchy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contextBlob) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CONTEXT),
            "::",
            stringify!(contextBlob)
        )
    );
}
impl Default for TPMS_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPMS_CREATION_DATA {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
    pub locality: TPMA_LOCALITY,
    pub parentNameAlg: TPM2_ALG_ID,
    pub parentName: TPM2B_NAME,
    pub parentQualifiedName: TPM2B_NAME,
    pub outsideInfo: TPM2B_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_CREATION_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_CREATION_DATA>(),
        408usize,
        concat!("Size of: ", stringify!(TPMS_CREATION_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_CREATION_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_CREATION_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrSelect) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(pcrSelect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcrDigest) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(pcrDigest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locality) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(locality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parentNameAlg) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentNameAlg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parentName) as usize - ptr as usize },
        202usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parentQualifiedName) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(parentQualifiedName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outsideInfo) as usize - ptr as usize },
        342usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_CREATION_DATA),
            "::",
            stringify!(outsideInfo)
        )
    );
}
impl Default for TPMS_CREATION_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPM2B_CREATION_DATA {
    pub size: UINT16,
    pub creationData: TPMS_CREATION_DATA,
}
#[test]
fn bindgen_test_layout_TPM2B_CREATION_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<TPM2B_CREATION_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPM2B_CREATION_DATA>(),
        412usize,
        concat!("Size of: ", stringify!(TPM2B_CREATION_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<TPM2B_CREATION_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(TPM2B_CREATION_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CREATION_DATA),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creationData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPM2B_CREATION_DATA),
            "::",
            stringify!(creationData)
        )
    );
}
impl Default for TPM2B_CREATION_DATA {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TPM_AT = UINT32;
pub type TPM_EA = UINT32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TPMS_AC_OUTPUT {
    pub tag: TPM_AT,
    pub data: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_AC_OUTPUT() {
    const UNINIT: ::std::mem::MaybeUninit<TPMS_AC_OUTPUT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPMS_AC_OUTPUT>(),
        8usize,
        concat!("Size of: ", stringify!(TPMS_AC_OUTPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<TPMS_AC_OUTPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(TPMS_AC_OUTPUT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AC_OUTPUT),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPMS_AC_OUTPUT),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPML_AC_CAPABILITIES {
    pub count: UINT32,
    pub acCapabilities: [TPMS_AC_OUTPUT; 128usize],
}
#[test]
fn bindgen_test_layout_TPML_AC_CAPABILITIES() {
    const UNINIT: ::std::mem::MaybeUninit<TPML_AC_CAPABILITIES> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TPML_AC_CAPABILITIES>(),
        1028usize,
        concat!("Size of: ", stringify!(TPML_AC_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<TPML_AC_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(TPML_AC_CAPABILITIES))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_AC_CAPABILITIES),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acCapabilities) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TPML_AC_CAPABILITIES),
            "::",
            stringify!(acCapabilities)
        )
    );
}
impl Default for TPML_AC_CAPABILITIES {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type nfds_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    const UNINIT: ::std::mem::MaybeUninit<pollfd> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    pub fn poll(
        __fds: *mut pollfd,
        __nfds: nfds_t,
        __timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type TSS2_TCTI_POLL_HANDLE = pollfd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSS2_TCTI_OPAQUE_CONTEXT_BLOB {
    _unused: [u8; 0],
}
pub type TSS2_TCTI_CONTEXT = TSS2_TCTI_OPAQUE_CONTEXT_BLOB;
pub type TSS2_TCTI_TRANSMIT_FCN = ::std::option::Option<
    unsafe extern "C" fn(
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        size: size_t,
        command: *const u8,
    ) -> TSS2_RC,
>;
pub type TSS2_TCTI_RECEIVE_FCN = ::std::option::Option<
    unsafe extern "C" fn(
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        size: *mut size_t,
        response: *mut u8,
        timeout: i32,
    ) -> TSS2_RC,
>;
pub type TSS2_TCTI_FINALIZE_FCN =
    ::std::option::Option<unsafe extern "C" fn(tctiContext: *mut TSS2_TCTI_CONTEXT)>;
pub type TSS2_TCTI_CANCEL_FCN =
    ::std::option::Option<unsafe extern "C" fn(tctiContext: *mut TSS2_TCTI_CONTEXT) -> TSS2_RC>;
pub type TSS2_TCTI_GET_POLL_HANDLES_FCN = ::std::option::Option<
    unsafe extern "C" fn(
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        handles: *mut TSS2_TCTI_POLL_HANDLE,
        num_handles: *mut size_t,
    ) -> TSS2_RC,
>;
pub type TSS2_TCTI_SET_LOCALITY_FCN = ::std::option::Option<
    unsafe extern "C" fn(tctiContext: *mut TSS2_TCTI_CONTEXT, locality: u8) -> TSS2_RC,
>;
pub type TSS2_TCTI_MAKE_STICKY_FCN = ::std::option::Option<
    unsafe extern "C" fn(
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        handle: *mut TPM2_HANDLE,
        sticky: u8,
    ) -> TSS2_RC,
>;
pub type TSS2_TCTI_INIT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        size: *mut size_t,
        config: *const ::std::os::raw::c_char,
    ) -> TSS2_RC,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TSS2_TCTI_CONTEXT_COMMON_V1 {
    pub magic: u64,
    pub version: u32,
    pub transmit: TSS2_TCTI_TRANSMIT_FCN,
    pub receive: TSS2_TCTI_RECEIVE_FCN,
    pub finalize: TSS2_TCTI_FINALIZE_FCN,
    pub cancel: TSS2_TCTI_CANCEL_FCN,
    pub getPollHandles: TSS2_TCTI_GET_POLL_HANDLES_FCN,
    pub setLocality: TSS2_TCTI_SET_LOCALITY_FCN,
}
#[test]
fn bindgen_test_layout_TSS2_TCTI_CONTEXT_COMMON_V1() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2_TCTI_CONTEXT_COMMON_V1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2_TCTI_CONTEXT_COMMON_V1>(),
        64usize,
        concat!("Size of: ", stringify!(TSS2_TCTI_CONTEXT_COMMON_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2_TCTI_CONTEXT_COMMON_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(TSS2_TCTI_CONTEXT_COMMON_V1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transmit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(transmit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(receive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).getPollHandles) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(getPollHandles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setLocality) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V1),
            "::",
            stringify!(setLocality)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct TSS2_TCTI_CONTEXT_COMMON_V2 {
    pub v1: TSS2_TCTI_CONTEXT_COMMON_V1,
    pub makeSticky: TSS2_TCTI_MAKE_STICKY_FCN,
}
#[test]
fn bindgen_test_layout_TSS2_TCTI_CONTEXT_COMMON_V2() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2_TCTI_CONTEXT_COMMON_V2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2_TCTI_CONTEXT_COMMON_V2>(),
        72usize,
        concat!("Size of: ", stringify!(TSS2_TCTI_CONTEXT_COMMON_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2_TCTI_CONTEXT_COMMON_V2>(),
        8usize,
        concat!("Alignment of ", stringify!(TSS2_TCTI_CONTEXT_COMMON_V2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V2),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).makeSticky) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_CONTEXT_COMMON_V2),
            "::",
            stringify!(makeSticky)
        )
    );
}
pub type TSS2_TCTI_CONTEXT_COMMON_CURRENT = TSS2_TCTI_CONTEXT_COMMON_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSS2_TCTI_INFO {
    pub version: u32,
    pub name: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub config_help: *const ::std::os::raw::c_char,
    pub init: TSS2_TCTI_INIT_FUNC,
}
#[test]
fn bindgen_test_layout_TSS2_TCTI_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2_TCTI_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2_TCTI_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(TSS2_TCTI_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2_TCTI_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(TSS2_TCTI_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_INFO),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config_help) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_INFO),
            "::",
            stringify!(config_help)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2_TCTI_INFO),
            "::",
            stringify!(init)
        )
    );
}
impl Default for TSS2_TCTI_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TSS2_TCTI_INFO_FUNC =
    ::std::option::Option<unsafe extern "C" fn() -> *const TSS2_TCTI_INFO>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TSS2_SYS_OPAQUE_CONTEXT_BLOB {
    _unused: [u8; 0],
}
pub type TSS2_SYS_CONTEXT = _TSS2_SYS_OPAQUE_CONTEXT_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSS2L_SYS_AUTH_COMMAND {
    pub count: u16,
    pub auths: [TPMS_AUTH_COMMAND; 3usize],
}
#[test]
fn bindgen_test_layout_TSS2L_SYS_AUTH_COMMAND() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2L_SYS_AUTH_COMMAND> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2L_SYS_AUTH_COMMAND>(),
        424usize,
        concat!("Size of: ", stringify!(TSS2L_SYS_AUTH_COMMAND))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2L_SYS_AUTH_COMMAND>(),
        4usize,
        concat!("Alignment of ", stringify!(TSS2L_SYS_AUTH_COMMAND))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2L_SYS_AUTH_COMMAND),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auths) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2L_SYS_AUTH_COMMAND),
            "::",
            stringify!(auths)
        )
    );
}
impl Default for TSS2L_SYS_AUTH_COMMAND {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSS2L_SYS_AUTH_RESPONSE {
    pub count: u16,
    pub auths: [TPMS_AUTH_RESPONSE; 3usize],
}
#[test]
fn bindgen_test_layout_TSS2L_SYS_AUTH_RESPONSE() {
    const UNINIT: ::std::mem::MaybeUninit<TSS2L_SYS_AUTH_RESPONSE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSS2L_SYS_AUTH_RESPONSE>(),
        404usize,
        concat!("Size of: ", stringify!(TSS2L_SYS_AUTH_RESPONSE))
    );
    assert_eq!(
        ::std::mem::align_of::<TSS2L_SYS_AUTH_RESPONSE>(),
        2usize,
        concat!("Alignment of ", stringify!(TSS2L_SYS_AUTH_RESPONSE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2L_SYS_AUTH_RESPONSE),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auths) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TSS2L_SYS_AUTH_RESPONSE),
            "::",
            stringify!(auths)
        )
    );
}
impl Default for TSS2L_SYS_AUTH_RESPONSE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn Tss2_Sys_GetContextSize(maxCommandResponseSize: size_t) -> size_t;
}
extern "C" {
    pub fn Tss2_Sys_Initialize(
        sysContext: *mut TSS2_SYS_CONTEXT,
        contextSize: size_t,
        tctiContext: *mut TSS2_TCTI_CONTEXT,
        abiVersion: *mut TSS2_ABI_VERSION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Finalize(sysContext: *mut TSS2_SYS_CONTEXT);
}
extern "C" {
    pub fn Tss2_Sys_GetTctiContext(
        sysContext: *mut TSS2_SYS_CONTEXT,
        tctiContext: *mut *mut TSS2_TCTI_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetDecryptParam(
        sysContext: *mut TSS2_SYS_CONTEXT,
        decryptParamSize: *mut size_t,
        decryptParamBuffer: *mut *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetDecryptParam(
        sysContext: *mut TSS2_SYS_CONTEXT,
        decryptParamSize: size_t,
        decryptParamBuffer: *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCpBuffer(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cpBufferUsedSize: *mut size_t,
        cpBuffer: *mut *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCmdAuths(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ExecuteAsync(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ExecuteFinish(sysContext: *mut TSS2_SYS_CONTEXT, timeout: i32) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Execute(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandCode(
        sysContext: *mut TSS2_SYS_CONTEXT,
        commandCode: *mut UINT8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRspAuths(
        sysContext: *mut TSS2_SYS_CONTEXT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetEncryptParam(
        sysContext: *mut TSS2_SYS_CONTEXT,
        encryptParamSize: *mut size_t,
        encryptParamBuffer: *mut *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetEncryptParam(
        sysContext: *mut TSS2_SYS_CONTEXT,
        encryptParamSize: size_t,
        encryptParamBuffer: *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRpBuffer(
        sysContext: *mut TSS2_SYS_CONTEXT,
        rpBufferUsedSize: *mut size_t,
        rpBuffer: *mut *const u8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Startup_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        startupType: TPM2_SU,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Startup_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Startup(sysContext: *mut TSS2_SYS_CONTEXT, startupType: TPM2_SU) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Shutdown_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        shutdownType: TPM2_SU,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Shutdown_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Shutdown(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        shutdownType: TPM2_SU,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SelfTest_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        fullTest: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SelfTest_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SelfTest(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        fullTest: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        toTest: *const TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        toDoList: *mut TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        toTest: *const TPML_ALG,
        toDoList: *mut TPML_ALG,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult_Prepare(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outData: *mut TPM2B_MAX_BUFFER,
        testResult: *mut TPM2_RC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        outData: *mut TPM2B_MAX_BUFFER,
        testResult: *mut TPM2_RC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        tpmKey: TPMI_DH_OBJECT,
        bind: TPMI_DH_ENTITY,
        nonceCaller: *const TPM2B_NONCE,
        encryptedSalt: *const TPM2B_ENCRYPTED_SECRET,
        sessionType: TPM2_SE,
        symmetric: *const TPMT_SYM_DEF,
        authHash: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sessionHandle: *mut TPMI_SH_AUTH_SESSION,
        nonceTPM: *mut TPM2B_NONCE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession(
        sysContext: *mut TSS2_SYS_CONTEXT,
        tpmKey: TPMI_DH_OBJECT,
        bind: TPMI_DH_ENTITY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        nonceCaller: *const TPM2B_NONCE,
        encryptedSalt: *const TPM2B_ENCRYPTED_SECRET,
        sessionType: TPM2_SE,
        symmetric: *const TPMT_SYM_DEF,
        authHash: TPMI_ALG_HASH,
        sessionHandle: *mut TPMI_SH_AUTH_SESSION,
        nonceTPM: *mut TPM2B_NONCE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyRestart_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sessionHandle: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyRestart_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyRestart(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sessionHandle: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outPrivate: *mut TPM2B_PRIVATE,
        outPublic: *mut TPM2B_PUBLIC,
        creationData: *mut TPM2B_CREATION_DATA,
        creationHash: *mut TPM2B_DIGEST,
        creationTicket: *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
        outPrivate: *mut TPM2B_PRIVATE,
        outPublic: *mut TPM2B_PUBLIC,
        creationData: *mut TPM2B_CREATION_DATA,
        creationHash: *mut TPM2B_DIGEST,
        creationTicket: *mut TPMT_TK_CREATION,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        inPrivate: *const TPM2B_PRIVATE,
        inPublic: *const TPM2B_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: *mut TPM2_HANDLE,
        name: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inPrivate: *const TPM2B_PRIVATE,
        inPublic: *const TPM2B_PUBLIC,
        objectHandle: *mut TPM2_HANDLE,
        name: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        inPrivate: *const TPM2B_SENSITIVE,
        inPublic: *const TPM2B_PUBLIC,
        hierarchy: TPMI_RH_HIERARCHY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: *mut TPM2_HANDLE,
        name: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inPrivate: *const TPM2B_SENSITIVE,
        inPublic: *const TPM2B_PUBLIC,
        hierarchy: TPMI_RH_HIERARCHY,
        objectHandle: *mut TPM2_HANDLE,
        name: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outPublic: *mut TPM2B_PUBLIC,
        name: *mut TPM2B_NAME,
        qualifiedName: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        outPublic: *mut TPM2B_PUBLIC,
        name: *mut TPM2B_NAME,
        qualifiedName: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        activateHandle: TPMI_DH_OBJECT,
        keyHandle: TPMI_DH_OBJECT,
        credentialBlob: *const TPM2B_ID_OBJECT,
        secret: *const TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        certInfo: *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential(
        sysContext: *mut TSS2_SYS_CONTEXT,
        activateHandle: TPMI_DH_OBJECT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        credentialBlob: *const TPM2B_ID_OBJECT,
        secret: *const TPM2B_ENCRYPTED_SECRET,
        certInfo: *mut TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        credential: *const TPM2B_DIGEST,
        objectName: *const TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        credentialBlob: *mut TPM2B_ID_OBJECT,
        secret: *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        credential: *const TPM2B_DIGEST,
        objectName: *const TPM2B_NAME,
        credentialBlob: *mut TPM2B_ID_OBJECT,
        secret: *mut TPM2B_ENCRYPTED_SECRET,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        itemHandle: TPMI_DH_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outData: *mut TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal(
        sysContext: *mut TSS2_SYS_CONTEXT,
        itemHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        outData: *mut TPM2B_SENSITIVE_DATA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        parentHandle: TPMI_DH_OBJECT,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outPrivate: *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        parentHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        newAuth: *const TPM2B_AUTH,
        outPrivate: *mut TPM2B_PRIVATE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        newParentHandle: TPMI_DH_OBJECT,
        encryptionKeyIn: *const TPM2B_DATA,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        encryptionKeyOut: *mut TPM2B_DATA,
        duplicate: *mut TPM2B_PRIVATE,
        outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        newParentHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        encryptionKeyIn: *const TPM2B_DATA,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
        encryptionKeyOut: *mut TPM2B_DATA,
        duplicate: *mut TPM2B_PRIVATE,
        outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        oldParent: TPMI_DH_OBJECT,
        newParent: TPMI_DH_OBJECT,
        inDuplicate: *const TPM2B_PRIVATE,
        name: *const TPM2B_NAME,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outDuplicate: *mut TPM2B_PRIVATE,
        outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap(
        sysContext: *mut TSS2_SYS_CONTEXT,
        oldParent: TPMI_DH_OBJECT,
        newParent: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inDuplicate: *const TPM2B_PRIVATE,
        name: *const TPM2B_NAME,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        outDuplicate: *mut TPM2B_PRIVATE,
        outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        encryptionKey: *const TPM2B_DATA,
        objectPublic: *const TPM2B_PUBLIC,
        duplicate: *const TPM2B_PRIVATE,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outPrivate: *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        encryptionKey: *const TPM2B_DATA,
        objectPublic: *const TPM2B_PUBLIC,
        duplicate: *const TPM2B_PRIVATE,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
        outPrivate: *mut TPM2B_PRIVATE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        message: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outData: *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        message: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
        outData: *mut TPM2B_PUBLIC_KEY_RSA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cipherText: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        message: *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        cipherText: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
        message: *mut TPM2B_PUBLIC_KEY_RSA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        zPoint: *mut TPM2B_ECC_POINT,
        pubPoint: *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        zPoint: *mut TPM2B_ECC_POINT,
        pubPoint: *mut TPM2B_ECC_POINT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        inPoint: *const TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outPoint: *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inPoint: *const TPM2B_ECC_POINT,
        outPoint: *mut TPM2B_ECC_POINT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        curveID: TPMI_ECC_CURVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parameters: *mut TPMS_ALGORITHM_DETAIL_ECC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        curveID: TPMI_ECC_CURVE,
        parameters: *mut TPMS_ALGORITHM_DETAIL_ECC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyA: TPMI_DH_OBJECT,
        inQsB: *const TPM2B_ECC_POINT,
        inQeB: *const TPM2B_ECC_POINT,
        inScheme: TPMI_ECC_KEY_EXCHANGE,
        counter: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outZ1: *mut TPM2B_ECC_POINT,
        outZ2: *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyA: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inQsB: *const TPM2B_ECC_POINT,
        inQeB: *const TPM2B_ECC_POINT,
        inScheme: TPMI_ECC_KEY_EXCHANGE,
        counter: UINT16,
        outZ1: *mut TPM2B_ECC_POINT,
        outZ2: *mut TPM2B_ECC_POINT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        inData: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outData: *mut TPM2B_MAX_BUFFER,
        ivOut: *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        inData: *const TPM2B_MAX_BUFFER,
        outData: *mut TPM2B_MAX_BUFFER,
        ivOut: *mut TPM2B_IV,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt2_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        inData: *const TPM2B_MAX_BUFFER,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt2_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outData: *mut TPM2B_MAX_BUFFER,
        ivOut: *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt2(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inData: *const TPM2B_MAX_BUFFER,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        outData: *mut TPM2B_MAX_BUFFER,
        ivOut: *mut TPM2B_IV,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        data: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        hierarchy: TPMI_RH_HIERARCHY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outHash: *mut TPM2B_DIGEST,
        validation: *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        data: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        hierarchy: TPMI_RH_HIERARCHY,
        outHash: *mut TPM2B_DIGEST,
        validation: *mut TPMT_TK_HASHCHECK,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        buffer: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outHMAC: *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        buffer: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        outHMAC: *mut TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        bytesRequested: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        randomBytes: *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        bytesRequested: UINT16,
        randomBytes: *mut TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StirRandom_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        inData: *const TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StirRandom_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_StirRandom(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inData: *const TPM2B_SENSITIVE_DATA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: *mut TPMI_DH_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start(
        sysContext: *mut TSS2_SYS_CONTEXT,
        handle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
        sequenceHandle: *mut TPMI_DH_OBJECT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: *mut TPMI_DH_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
        sequenceHandle: *mut TPMI_DH_OBJECT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceUpdate_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: TPMI_DH_OBJECT,
        buffer: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceUpdate_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceUpdate(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        buffer: *const TPM2B_MAX_BUFFER,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: TPMI_DH_OBJECT,
        buffer: *const TPM2B_MAX_BUFFER,
        hierarchy: TPMI_RH_HIERARCHY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        result: *mut TPM2B_DIGEST,
        validation: *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        buffer: *const TPM2B_MAX_BUFFER,
        hierarchy: TPMI_RH_HIERARCHY,
        result: *mut TPM2B_DIGEST,
        validation: *mut TPMT_TK_HASHCHECK,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        sequenceHandle: TPMI_DH_OBJECT,
        buffer: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        results: *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        sequenceHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        buffer: *const TPM2B_MAX_BUFFER,
        results: *mut TPML_DIGEST_VALUES,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        signHandle: TPMI_DH_OBJECT,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyX509_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        signHandle: TPMI_DH_OBJECT,
        reserved: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        partialCertificate: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyX509_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        addedToCertificate: *mut TPM2B_MAX_BUFFER,
        tbsDigest: *mut TPM2B_DIGEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyX509(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: TPMI_DH_OBJECT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        reserved: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        partialCertificate: *const TPM2B_MAX_BUFFER,
        addedToCertificate: *mut TPM2B_MAX_BUFFER,
        tbsDigest: *mut TPM2B_DIGEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        objectHandle: TPMI_DH_OBJECT,
        qualifyingData: *const TPM2B_DATA,
        creationHash: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        creationTicket: *const TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        objectHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        creationHash: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        creationTicket: *const TPMT_TK_CREATION,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        PCRselect: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        quoted: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        PCRselect: *const TPML_PCR_SELECTION,
        quoted: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyAdminHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        sessionHandle: TPMI_SH_HMAC,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auditInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyAdminHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        sessionHandle: TPMI_SH_HMAC,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        auditInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auditInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        auditInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyAdminHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        timeInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime(
        sysContext: *mut TSS2_SYS_CONTEXT,
        privacyAdminHandle: TPMI_RH_ENDORSEMENT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        timeInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        P1: *const TPM2B_ECC_POINT,
        s2: *const TPM2B_SENSITIVE_DATA,
        y2: *const TPM2B_ECC_PARAMETER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        K: *mut TPM2B_ECC_POINT,
        L: *mut TPM2B_ECC_POINT,
        E: *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        P1: *const TPM2B_ECC_POINT,
        s2: *const TPM2B_SENSITIVE_DATA,
        y2: *const TPM2B_ECC_PARAMETER,
        K: *mut TPM2B_ECC_POINT,
        L: *mut TPM2B_ECC_POINT,
        E: *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        curveID: TPMI_ECC_CURVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        Q: *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        curveID: TPMI_ECC_CURVE,
        Q: *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        digest: *const TPM2B_DIGEST,
        signature: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        validation: *mut TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        digest: *const TPM2B_DIGEST,
        signature: *const TPMT_SIGNATURE,
        validation: *mut TPMT_TK_VERIFIED,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        digest: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        validation: *const TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign(
        sysContext: *mut TSS2_SYS_CONTEXT,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        digest: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        validation: *const TPMT_TK_HASHCHECK,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCommandCodeAuditStatus_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        auditAlg: TPMI_ALG_HASH,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCommandCodeAuditStatus_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCommandCodeAuditStatus(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        auditAlg: TPMI_ALG_HASH,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Extend_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        digests: *const TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Extend_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Extend(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        digests: *const TPML_DIGEST_VALUES,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        eventData: *const TPM2B_EVENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        digests: *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        eventData: *const TPM2B_EVENT,
        digests: *mut TPML_DIGEST_VALUES,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrSelectionIn: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrUpdateCounter: *mut UINT32,
        pcrSelectionOut: *mut TPML_PCR_SELECTION,
        pcrValues: *mut TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        pcrSelectionIn: *const TPML_PCR_SELECTION,
        pcrUpdateCounter: *mut UINT32,
        pcrSelectionOut: *mut TPML_PCR_SELECTION,
        pcrValues: *mut TPML_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        pcrAllocation: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        allocationSuccess: *mut TPMI_YES_NO,
        maxPCR: *mut UINT32,
        sizeNeeded: *mut UINT32,
        sizeAvailable: *mut UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        pcrAllocation: *const TPML_PCR_SELECTION,
        allocationSuccess: *mut TPMI_YES_NO,
        maxPCR: *mut UINT32,
        sizeNeeded: *mut UINT32,
        sizeAvailable: *mut UINT32,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthPolicy_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
        pcrNum: TPMI_DH_PCR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthPolicy_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthPolicy(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
        pcrNum: TPMI_DH_PCR,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthValue_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        auth: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthValue_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthValue(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        auth: *const TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Reset_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Reset_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Reset(
        sysContext: *mut TSS2_SYS_CONTEXT,
        pcrHandle: TPMI_DH_PCR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authObject: TPMI_DH_OBJECT,
        policySession: TPMI_SH_POLICY,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        auth: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        timeout: *mut TPM2B_TIMEOUT,
        policyTicket: *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authObject: TPMI_DH_OBJECT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        auth: *const TPMT_SIGNATURE,
        timeout: *mut TPM2B_TIMEOUT,
        policyTicket: *mut TPMT_TK_AUTH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_DH_ENTITY,
        policySession: TPMI_SH_POLICY,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        timeout: *mut TPM2B_TIMEOUT,
        policyTicket: *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_DH_ENTITY,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        timeout: *mut TPM2B_TIMEOUT,
        policyTicket: *mut TPMT_TK_AUTH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTicket_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        timeout: *const TPM2B_TIMEOUT,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        authName: *const TPM2B_NAME,
        ticket: *const TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTicket_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTicket(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        timeout: *const TPM2B_TIMEOUT,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        authName: *const TPM2B_NAME,
        ticket: *const TPMT_TK_AUTH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyOR_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        pHashList: *const TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyOR_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyOR(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        pHashList: *const TPML_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPCR_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        pcrDigest: *const TPM2B_DIGEST,
        pcrs: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPCR_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPCR(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        pcrDigest: *const TPM2B_DIGEST,
        pcrs: *const TPML_PCR_SELECTION,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyLocality_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        locality: TPMA_LOCALITY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyLocality_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyLocality(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        locality: TPMA_LOCALITY,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNV_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        policySession: TPMI_SH_POLICY,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNV_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNV(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCounterTimer_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCounterTimer_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCounterTimer(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCommandCode_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        code: TPM2_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCommandCode_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCommandCode(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        code: TPM2_CC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPhysicalPresence_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPhysicalPresence_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPhysicalPresence(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCpHash_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cpHashA: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCpHash_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCpHash(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        cpHashA: *const TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNameHash_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        nameHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNameHash_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNameHash(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        nameHash: *const TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyDuplicationSelect_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        objectName: *const TPM2B_NAME,
        newParentName: *const TPM2B_NAME,
        includeObject: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyDuplicationSelect_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyDuplicationSelect(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        objectName: *const TPM2B_NAME,
        newParentName: *const TPM2B_NAME,
        includeObject: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorize_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        approvedPolicy: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        keySign: *const TPM2B_NAME,
        checkTicket: *const TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorize_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorize(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        approvedPolicy: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        keySign: *const TPM2B_NAME,
        checkTicket: *const TPMT_TK_VERIFIED,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthValue_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthValue_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthValue(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPassword_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPassword_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPassword(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policyDigest: *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        policyDigest: *mut TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNvWritten_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        writtenSet: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNvWritten_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNvWritten(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        writtenSet: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        primaryHandle: TPMI_RH_HIERARCHY,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: *mut TPM2_HANDLE,
        outPublic: *mut TPM2B_PUBLIC,
        creationData: *mut TPM2B_CREATION_DATA,
        creationHash: *mut TPM2B_DIGEST,
        creationTicket: *mut TPMT_TK_CREATION,
        name: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary(
        sysContext: *mut TSS2_SYS_CONTEXT,
        primaryHandle: TPMI_RH_HIERARCHY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
        objectHandle: *mut TPM2_HANDLE,
        outPublic: *mut TPM2B_PUBLIC,
        creationData: *mut TPM2B_CREATION_DATA,
        creationHash: *mut TPM2B_DIGEST,
        creationTicket: *mut TPMT_TK_CREATION,
        name: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyControl_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY,
        enable: TPMI_RH_ENABLES,
        state: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyControl_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyControl(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        enable: TPMI_RH_ENABLES,
        state: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetPrimaryPolicy_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY_AUTH,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetPrimaryPolicy_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetPrimaryPolicy(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY_AUTH,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangePPS_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangePPS_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangePPS(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangeEPS_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangeEPS_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangeEPS(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Clear_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_CLEAR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Clear_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Clear(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_CLEAR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClearControl_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_CLEAR,
        disable: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClearControl_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClearControl(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_CLEAR,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        disable: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyChangeAuth_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY_AUTH,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyChangeAuth_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyChangeAuth(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_HIERARCHY_AUTH,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        newAuth: *const TPM2B_AUTH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackLockReset_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        lockHandle: TPMI_RH_LOCKOUT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackLockReset_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackLockReset(
        sysContext: *mut TSS2_SYS_CONTEXT,
        lockHandle: TPMI_RH_LOCKOUT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackParameters_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        lockHandle: TPMI_RH_LOCKOUT,
        newMaxTries: UINT32,
        newRecoveryTime: UINT32,
        lockoutRecovery: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackParameters_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackParameters(
        sysContext: *mut TSS2_SYS_CONTEXT,
        lockHandle: TPMI_RH_LOCKOUT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        newMaxTries: UINT32,
        newRecoveryTime: UINT32,
        lockoutRecovery: UINT32,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PP_Commands_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PLATFORM,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PP_Commands_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PP_Commands(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetAlgorithmSet_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        algorithmSet: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetAlgorithmSet_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetAlgorithmSet(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        algorithmSet: UINT32,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeStart_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authorization: TPMI_RH_PLATFORM,
        keyHandle: TPMI_DH_OBJECT,
        fuDigest: *const TPM2B_DIGEST,
        manifestSignature: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeStart_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeStart(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authorization: TPMI_RH_PLATFORM,
        keyHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        fuDigest: *const TPM2B_DIGEST,
        manifestSignature: *const TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        fuData: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nextDigest: *mut TPMT_HA,
        firstDigest: *mut TPMT_HA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        fuData: *const TPM2B_MAX_BUFFER,
        nextDigest: *mut TPMT_HA,
        firstDigest: *mut TPMT_HA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sequenceNumber: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        fuData: *mut TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        sequenceNumber: UINT32,
        fuData: *mut TPM2B_MAX_BUFFER,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        saveHandle: TPMI_DH_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        context: *mut TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave(
        sysContext: *mut TSS2_SYS_CONTEXT,
        saveHandle: TPMI_DH_CONTEXT,
        context: *mut TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        context: *const TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        loadedHandle: *mut TPMI_DH_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad(
        sysContext: *mut TSS2_SYS_CONTEXT,
        context: *const TPMS_CONTEXT,
        loadedHandle: *mut TPMI_DH_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FlushContext_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        flushHandle: TPMI_DH_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FlushContext_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_FlushContext(
        sysContext: *mut TSS2_SYS_CONTEXT,
        flushHandle: TPMI_DH_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EvictControl_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        objectHandle: TPMI_DH_OBJECT,
        persistentHandle: TPMI_DH_PERSISTENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EvictControl_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_EvictControl(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        objectHandle: TPMI_DH_OBJECT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        persistentHandle: TPMI_DH_PERSISTENT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock_Prepare(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        currentTime: *mut TPMS_TIME_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        currentTime: *mut TPMS_TIME_INFO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockSet_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        newTime: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockSet_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockSet(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        newTime: UINT64,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockRateAdjust_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        rateAdjust: TPM2_CLOCK_ADJUST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockRateAdjust_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockRateAdjust(
        sysContext: *mut TSS2_SYS_CONTEXT,
        auth: TPMI_RH_PROVISION,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rateAdjust: TPM2_CLOCK_ADJUST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        capability: TPM2_CAP,
        property: UINT32,
        propertyCount: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut TPMS_CAPABILITY_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        capability: TPM2_CAP,
        property: UINT32,
        propertyCount: UINT32,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut TPMS_CAPABILITY_DATA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_TestParms_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parameters: *const TPMT_PUBLIC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_TestParms_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_TestParms(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        parameters: *const TPMT_PUBLIC_PARMS,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_DefineSpace_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
        auth: *const TPM2B_AUTH,
        publicInfo: *const TPM2B_NV_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_DefineSpace_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_DefineSpace(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        auth: *const TPM2B_AUTH,
        publicInfo: *const TPM2B_NV_PUBLIC,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpace_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
        nvIndex: TPMI_RH_NV_INDEX,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpace_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpace(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpaceSpecial_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
        platform: TPMI_RH_PLATFORM,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpaceSpecial_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpaceSpecial(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
        platform: TPMI_RH_PLATFORM,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvPublic: *mut TPM2B_NV_PUBLIC,
        nvName: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        nvPublic: *mut TPM2B_NV_PUBLIC,
        nvName: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Write_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        data: *const TPM2B_MAX_NV_BUFFER,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Write_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Write(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        data: *const TPM2B_MAX_NV_BUFFER,
        offset: UINT16,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Increment_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Increment_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Increment(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Extend_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        data: *const TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Extend_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Extend(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        data: *const TPM2B_MAX_NV_BUFFER,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_SetBits_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        bits: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_SetBits_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_SetBits(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        bits: UINT64,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_WriteLock_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_WriteLock_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_WriteLock(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_GlobalWriteLock_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_GlobalWriteLock_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_GlobalWriteLock(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_PROVISION,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        size: UINT16,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        data: *mut TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        size: UINT16,
        offset: UINT16,
        data: *mut TPM2B_MAX_NV_BUFFER,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadLock_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadLock_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadLock(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ChangeAuth_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ChangeAuth_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ChangeAuth(
        sysContext: *mut TSS2_SYS_CONTEXT,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        newAuth: *const TPM2B_AUTH,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        size: UINT16,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify(
        sysContext: *mut TSS2_SYS_CONTEXT,
        signHandle: TPMI_DH_OBJECT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        size: UINT16,
        offset: UINT16,
        certifyInfo: *mut TPM2B_ATTEST,
        signature: *mut TPMT_SIGNATURE,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        inputData: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        outputData: *mut TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test(
        sysContext: *mut TSS2_SYS_CONTEXT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inputData: *const TPM2B_DATA,
        outputData: *mut TPM2B_DATA,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_GetCapability_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        ac: TPMI_RH_AC,
        capability: TPM_AT,
        count: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_GetCapability_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut TPML_AC_CAPABILITIES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_GetCapability(
        sysContext: *mut TSS2_SYS_CONTEXT,
        ac: TPMI_RH_AC,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        capability: TPM_AT,
        count: UINT32,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut TPML_AC_CAPABILITIES,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_Send_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sendObject: TPMI_DH_OBJECT,
        authHandle: TPMI_RH_NV_AUTH,
        ac: TPMI_RH_AC,
        acDataIn: *mut TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_Send_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        acDataOut: *mut TPMS_AC_OUTPUT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_AC_Send(
        sysContext: *mut TSS2_SYS_CONTEXT,
        sendObject: TPMI_DH_OBJECT,
        authHandle: TPMI_RH_NV_AUTH,
        ac: TPMI_RH_AC,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        acDataIn: *mut TPM2B_MAX_BUFFER,
        acDataOut: *mut TPMS_AC_OUTPUT,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Policy_AC_SendSelect_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        objectName: *mut TPM2B_NAME,
        authHandleName: *mut TPM2B_NAME,
        acName: *mut TPM2B_NAME,
        includeObject: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Policy_AC_SendSelect_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Policy_AC_SendSelect(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        objectName: *mut TPM2B_NAME,
        authHandleName: *mut TPM2B_NAME,
        acName: *mut TPM2B_NAME,
        includeObject: TPMI_YES_NO,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ACT_SetTimeout_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        actHandle: TPMI_RH_ACT,
        startTimeout: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ACT_SetTimeout_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ACT_SetTimeout(
        sysContext: *mut TSS2_SYS_CONTEXT,
        actHandle: TPMI_RH_ACT,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        startTimeout: UINT32,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTemplate_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        templateHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTemplate_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTemplate(
        sysContext: *mut TSS2_SYS_CONTEXT,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        templateHash: *const TPM2B_DIGEST,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreateLoaded_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_RH_HIERARCHY,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_TEMPLATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreateLoaded_Complete(
        sysContext: *mut TSS2_SYS_CONTEXT,
        objectHandle: *mut TPM2_HANDLE,
        outPrivate: *mut TPM2B_PRIVATE,
        outPublic: *mut TPM2B_PUBLIC,
        name: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreateLoaded(
        sysContext: *mut TSS2_SYS_CONTEXT,
        parentHandle: TPMI_RH_HIERARCHY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_TEMPLATE,
        objectHandle: *mut TPM2_HANDLE,
        outPrivate: *mut TPM2B_PRIVATE,
        outPublic: *mut TPM2B_PUBLIC,
        name: *mut TPM2B_NAME,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorizeNV_Prepare(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        policySession: TPMI_SH_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorizeNV_Complete(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorizeNV(
        sysContext: *mut TSS2_SYS_CONTEXT,
        authHandle: TPMI_RH_NV_AUTH,
        nvIndex: TPMI_RH_NV_INDEX,
        policySession: TPMI_SH_POLICY,
        cmdAuthsArray: *const TSS2L_SYS_AUTH_COMMAND,
        rspAuthsArray: *mut TSS2L_SYS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
pub type ESYS_TR = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ESYS_CONTEXT {
    _unused: [u8; 0],
}
extern "C" {
    pub fn Esys_Initialize(
        esys_context: *mut *mut ESYS_CONTEXT,
        tcti: *mut TSS2_TCTI_CONTEXT,
        abiVersion: *mut TSS2_ABI_VERSION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Finalize(context: *mut *mut ESYS_CONTEXT);
}
extern "C" {
    pub fn Esys_GetTcti(
        esys_context: *mut ESYS_CONTEXT,
        tcti: *mut *mut TSS2_TCTI_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetPollHandles(
        esys_context: *mut ESYS_CONTEXT,
        handles: *mut *mut TSS2_TCTI_POLL_HANDLE,
        count: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetTimeout(esys_context: *mut ESYS_CONTEXT, timeout: i32) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_Serialize(
        esys_context: *mut ESYS_CONTEXT,
        object: ESYS_TR,
        buffer: *mut *mut u8,
        buffer_size: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_Deserialize(
        esys_context: *mut ESYS_CONTEXT,
        buffer: *const u8,
        buffer_size: size_t,
        esys_handle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_FromTPMPublic_Async(
        esysContext: *mut ESYS_CONTEXT,
        tpm_handle: TPM2_HANDLE,
        optionalSession1: ESYS_TR,
        optionalSession2: ESYS_TR,
        optionalSession3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_FromTPMPublic_Finish(
        esysContext: *mut ESYS_CONTEXT,
        object: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_FromTPMPublic(
        esysContext: *mut ESYS_CONTEXT,
        tpm_handle: TPM2_HANDLE,
        optionalSession1: ESYS_TR,
        optionalSession2: ESYS_TR,
        optionalSession3: ESYS_TR,
        object: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_Close(esys_context: *mut ESYS_CONTEXT, rsrc_handle: *mut ESYS_TR) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_SetAuth(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        authValue: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_GetName(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        name: *mut *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TRSess_GetAttributes(
        esysContext: *mut ESYS_CONTEXT,
        session: ESYS_TR,
        flags: *mut TPMA_SESSION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TRSess_SetAttributes(
        esysContext: *mut ESYS_CONTEXT,
        session: ESYS_TR,
        flags: TPMA_SESSION,
        mask: TPMA_SESSION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TRSess_GetNonceTPM(
        esysContext: *mut ESYS_CONTEXT,
        session: ESYS_TR,
        nonceTPM: *mut *mut TPM2B_NONCE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TR_GetTpmHandle(
        esys_context: *mut ESYS_CONTEXT,
        esys_handle: ESYS_TR,
        tpm_handle: *mut TPM2_HANDLE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TRSess_GetAuthRequired(
        esys_context: *mut ESYS_CONTEXT,
        esys_handle: ESYS_TR,
        auth_needed: *mut TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Startup(esysContext: *mut ESYS_CONTEXT, startupType: TPM2_SU) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Startup_Async(esysContext: *mut ESYS_CONTEXT, startupType: TPM2_SU) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Startup_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Shutdown(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        shutdownType: TPM2_SU,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Shutdown_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        shutdownType: TPM2_SU,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Shutdown_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SelfTest(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fullTest: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SelfTest_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fullTest: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SelfTest_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_IncrementalSelfTest(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        toTest: *const TPML_ALG,
        toDoList: *mut *mut TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_IncrementalSelfTest_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        toTest: *const TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_IncrementalSelfTest_Finish(
        esysContext: *mut ESYS_CONTEXT,
        toDoList: *mut *mut TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTestResult(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        testResult: *mut TPM2_RC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTestResult_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTestResult_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        testResult: *mut TPM2_RC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StartAuthSession(
        esysContext: *mut ESYS_CONTEXT,
        tpmKey: ESYS_TR,
        bind: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceCaller: *const TPM2B_NONCE,
        sessionType: TPM2_SE,
        symmetric: *const TPMT_SYM_DEF,
        authHash: TPMI_ALG_HASH,
        sessionHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StartAuthSession_Async(
        esysContext: *mut ESYS_CONTEXT,
        tpmKey: ESYS_TR,
        bind: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceCaller: *const TPM2B_NONCE,
        sessionType: TPM2_SE,
        symmetric: *const TPMT_SYM_DEF,
        authHash: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StartAuthSession_Finish(
        esysContext: *mut ESYS_CONTEXT,
        sessionHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyRestart(
        esysContext: *mut ESYS_CONTEXT,
        sessionHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyRestart_Async(
        esysContext: *mut ESYS_CONTEXT,
        sessionHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyRestart_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Create(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
        outPrivate: *mut *mut TPM2B_PRIVATE,
        outPublic: *mut *mut TPM2B_PUBLIC,
        creationData: *mut *mut TPM2B_CREATION_DATA,
        creationHash: *mut *mut TPM2B_DIGEST,
        creationTicket: *mut *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Create_Async(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Create_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outPrivate: *mut *mut TPM2B_PRIVATE,
        outPublic: *mut *mut TPM2B_PUBLIC,
        creationData: *mut *mut TPM2B_CREATION_DATA,
        creationHash: *mut *mut TPM2B_DIGEST,
        creationTicket: *mut *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Load(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPrivate: *const TPM2B_PRIVATE,
        inPublic: *const TPM2B_PUBLIC,
        objectHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Load_Async(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPrivate: *const TPM2B_PRIVATE,
        inPublic: *const TPM2B_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Load_Finish(esysContext: *mut ESYS_CONTEXT, objectHandle: *mut ESYS_TR) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_LoadExternal(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPrivate: *const TPM2B_SENSITIVE,
        inPublic: *const TPM2B_PUBLIC,
        hierarchy: ESYS_TR,
        objectHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_LoadExternal_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPrivate: *const TPM2B_SENSITIVE,
        inPublic: *const TPM2B_PUBLIC,
        hierarchy: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_LoadExternal_Finish(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadPublic(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        outPublic: *mut *mut TPM2B_PUBLIC,
        name: *mut *mut TPM2B_NAME,
        qualifiedName: *mut *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadPublic_Async(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadPublic_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outPublic: *mut *mut TPM2B_PUBLIC,
        name: *mut *mut TPM2B_NAME,
        qualifiedName: *mut *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ActivateCredential(
        esysContext: *mut ESYS_CONTEXT,
        activateHandle: ESYS_TR,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        credentialBlob: *const TPM2B_ID_OBJECT,
        secret: *const TPM2B_ENCRYPTED_SECRET,
        certInfo: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ActivateCredential_Async(
        esysContext: *mut ESYS_CONTEXT,
        activateHandle: ESYS_TR,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        credentialBlob: *const TPM2B_ID_OBJECT,
        secret: *const TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ActivateCredential_Finish(
        esysContext: *mut ESYS_CONTEXT,
        certInfo: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ACT_SetTimeout(
        esysContext: *mut ESYS_CONTEXT,
        actHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        startTimeout: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ACT_SetTimeout_Async(
        esysContext: *mut ESYS_CONTEXT,
        actHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        startTimeout: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ACT_SetTimeout_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_MakeCredential(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        credential: *const TPM2B_DIGEST,
        objectName: *const TPM2B_NAME,
        credentialBlob: *mut *mut TPM2B_ID_OBJECT,
        secret: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_MakeCredential_Async(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        credential: *const TPM2B_DIGEST,
        objectName: *const TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_MakeCredential_Finish(
        esysContext: *mut ESYS_CONTEXT,
        credentialBlob: *mut *mut TPM2B_ID_OBJECT,
        secret: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Unseal(
        esysContext: *mut ESYS_CONTEXT,
        itemHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        outData: *mut *mut TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Unseal_Async(
        esysContext: *mut ESYS_CONTEXT,
        itemHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Unseal_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outData: *mut *mut TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ObjectChangeAuth(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
        outPrivate: *mut *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ObjectChangeAuth_Async(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ObjectChangeAuth_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outPrivate: *mut *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreateLoaded(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_TEMPLATE,
        objectHandle: *mut ESYS_TR,
        outPrivate: *mut *mut TPM2B_PRIVATE,
        outPublic: *mut *mut TPM2B_PUBLIC,
        // Is this missing NAME?
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreateLoaded_Async(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_TEMPLATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreateLoaded_Finish(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: *mut ESYS_TR,
        outPrivate: *mut *mut TPM2B_PRIVATE,
        outPublic: *mut *mut TPM2B_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Duplicate(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        newParentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        encryptionKeyIn: *const TPM2B_DATA,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
        encryptionKeyOut: *mut *mut TPM2B_DATA,
        duplicate: *mut *mut TPM2B_PRIVATE,
        outSymSeed: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Duplicate_Async(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        newParentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        encryptionKeyIn: *const TPM2B_DATA,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Duplicate_Finish(
        esysContext: *mut ESYS_CONTEXT,
        encryptionKeyOut: *mut *mut TPM2B_DATA,
        duplicate: *mut *mut TPM2B_PRIVATE,
        outSymSeed: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Rewrap(
        esysContext: *mut ESYS_CONTEXT,
        oldParent: ESYS_TR,
        newParent: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inDuplicate: *const TPM2B_PRIVATE,
        name: *const TPM2B_NAME,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        outDuplicate: *mut *mut TPM2B_PRIVATE,
        outSymSeed: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Rewrap_Async(
        esysContext: *mut ESYS_CONTEXT,
        oldParent: ESYS_TR,
        newParent: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inDuplicate: *const TPM2B_PRIVATE,
        name: *const TPM2B_NAME,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Rewrap_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outDuplicate: *mut *mut TPM2B_PRIVATE,
        outSymSeed: *mut *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Import(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        encryptionKey: *const TPM2B_DATA,
        objectPublic: *const TPM2B_PUBLIC,
        duplicate: *const TPM2B_PRIVATE,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
        outPrivate: *mut *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Import_Async(
        esysContext: *mut ESYS_CONTEXT,
        parentHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        encryptionKey: *const TPM2B_DATA,
        objectPublic: *const TPM2B_PUBLIC,
        duplicate: *const TPM2B_PRIVATE,
        inSymSeed: *const TPM2B_ENCRYPTED_SECRET,
        symmetricAlg: *const TPMT_SYM_DEF_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Import_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outPrivate: *mut *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Encrypt(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        message: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
        outData: *mut *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Encrypt_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        message: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Encrypt_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outData: *mut *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Decrypt(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        cipherText: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
        message: *mut *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Decrypt_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        cipherText: *const TPM2B_PUBLIC_KEY_RSA,
        inScheme: *const TPMT_RSA_DECRYPT,
        label: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_RSA_Decrypt_Finish(
        esysContext: *mut ESYS_CONTEXT,
        message: *mut *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_KeyGen(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        zPoint: *mut *mut TPM2B_ECC_POINT,
        pubPoint: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_KeyGen_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_KeyGen_Finish(
        esysContext: *mut ESYS_CONTEXT,
        zPoint: *mut *mut TPM2B_ECC_POINT,
        pubPoint: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_ZGen(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPoint: *const TPM2B_ECC_POINT,
        outPoint: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_ZGen_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inPoint: *const TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECDH_ZGen_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outPoint: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECC_Parameters(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        curveID: TPMI_ECC_CURVE,
        parameters: *mut *mut TPMS_ALGORITHM_DETAIL_ECC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECC_Parameters_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        curveID: TPMI_ECC_CURVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ECC_Parameters_Finish(
        esysContext: *mut ESYS_CONTEXT,
        parameters: *mut *mut TPMS_ALGORITHM_DETAIL_ECC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ZGen_2Phase(
        esysContext: *mut ESYS_CONTEXT,
        keyA: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inQsB: *const TPM2B_ECC_POINT,
        inQeB: *const TPM2B_ECC_POINT,
        inScheme: TPMI_ECC_KEY_EXCHANGE,
        counter: UINT16,
        outZ1: *mut *mut TPM2B_ECC_POINT,
        outZ2: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ZGen_2Phase_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyA: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inQsB: *const TPM2B_ECC_POINT,
        inQeB: *const TPM2B_ECC_POINT,
        inScheme: TPMI_ECC_KEY_EXCHANGE,
        counter: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ZGen_2Phase_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outZ1: *mut *mut TPM2B_ECC_POINT,
        outZ2: *mut *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        inData: *const TPM2B_MAX_BUFFER,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        ivOut: *mut *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        inData: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        ivOut: *mut *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt2(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inData: *const TPM2B_MAX_BUFFER,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        ivOut: *mut *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt2_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inData: *const TPM2B_MAX_BUFFER,
        decrypt: TPMI_YES_NO,
        mode: TPMI_ALG_CIPHER_MODE,
        ivIn: *const TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EncryptDecrypt2_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outData: *mut *mut TPM2B_MAX_BUFFER,
        ivOut: *mut *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Hash(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        hierarchy: ESYS_TR,
        outHash: *mut *mut TPM2B_DIGEST,
        validation: *mut *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Hash_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        hierarchy: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Hash_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outHash: *mut *mut TPM2B_DIGEST,
        validation: *mut *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
        outHMAC: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC_Async(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outHMAC: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetRandom(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        bytesRequested: UINT16,
        randomBytes: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetRandom_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        bytesRequested: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetRandom_Finish(
        esysContext: *mut ESYS_CONTEXT,
        randomBytes: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StirRandom(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inData: *const TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StirRandom_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inData: *const TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_StirRandom_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC_Start(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
        sequenceHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC_Start_Async(
        esysContext: *mut ESYS_CONTEXT,
        handle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HMAC_Start_Finish(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HashSequenceStart(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
        sequenceHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HashSequenceStart_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HashSequenceStart_Finish(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceUpdate(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceUpdate_Async(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceUpdate_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceComplete(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
        hierarchy: ESYS_TR,
        result: *mut *mut TPM2B_DIGEST,
        validation: *mut *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceComplete_Async(
        esysContext: *mut ESYS_CONTEXT,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
        hierarchy: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SequenceComplete_Finish(
        esysContext: *mut ESYS_CONTEXT,
        result: *mut *mut TPM2B_DIGEST,
        validation: *mut *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EventSequenceComplete(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
        results: *mut *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EventSequenceComplete_Async(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        sequenceHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        buffer: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EventSequenceComplete_Finish(
        esysContext: *mut ESYS_CONTEXT,
        results: *mut *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Certify(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Certify_Async(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Certify_Finish(
        esysContext: *mut ESYS_CONTEXT,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyCreation(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        creationHash: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        creationTicket: *const TPMT_TK_CREATION,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyCreation_Async(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        creationHash: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        creationTicket: *const TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyCreation_Finish(
        esysContext: *mut ESYS_CONTEXT,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyX509(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        reserved: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        partialCertificate: *const TPM2B_MAX_BUFFER,
        addedToCertificate: *mut *mut TPM2B_MAX_BUFFER,
        tbsDigest: *mut *mut TPM2B_DIGEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyX509_Async(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        reserved: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        partialCertificate: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CertifyX509_Finish(
        esysContext: *mut ESYS_CONTEXT,
        addedToCertificate: *mut *mut TPM2B_MAX_BUFFER,
        tbsDigest: *mut *mut TPM2B_DIGEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Quote(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        PCRselect: *const TPML_PCR_SELECTION,
        quoted: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Quote_Async(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        PCRselect: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Quote_Finish(
        esysContext: *mut ESYS_CONTEXT,
        quoted: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetSessionAuditDigest(
        esysContext: *mut ESYS_CONTEXT,
        privacyAdminHandle: ESYS_TR,
        signHandle: ESYS_TR,
        sessionHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        auditInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetSessionAuditDigest_Async(
        esysContext: *mut ESYS_CONTEXT,
        privacyAdminHandle: ESYS_TR,
        signHandle: ESYS_TR,
        sessionHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetSessionAuditDigest_Finish(
        esysContext: *mut ESYS_CONTEXT,
        auditInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCommandAuditDigest(
        esysContext: *mut ESYS_CONTEXT,
        privacyHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        auditInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCommandAuditDigest_Async(
        esysContext: *mut ESYS_CONTEXT,
        privacyHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCommandAuditDigest_Finish(
        esysContext: *mut ESYS_CONTEXT,
        auditInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTime(
        esysContext: *mut ESYS_CONTEXT,
        privacyAdminHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        timeInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTime_Async(
        esysContext: *mut ESYS_CONTEXT,
        privacyAdminHandle: ESYS_TR,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetTime_Finish(
        esysContext: *mut ESYS_CONTEXT,
        timeInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Commit(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        P1: *const TPM2B_ECC_POINT,
        s2: *const TPM2B_SENSITIVE_DATA,
        y2: *const TPM2B_ECC_PARAMETER,
        K: *mut *mut TPM2B_ECC_POINT,
        L: *mut *mut TPM2B_ECC_POINT,
        E: *mut *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Commit_Async(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        P1: *const TPM2B_ECC_POINT,
        s2: *const TPM2B_SENSITIVE_DATA,
        y2: *const TPM2B_ECC_PARAMETER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Commit_Finish(
        esysContext: *mut ESYS_CONTEXT,
        K: *mut *mut TPM2B_ECC_POINT,
        L: *mut *mut TPM2B_ECC_POINT,
        E: *mut *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EC_Ephemeral(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        curveID: TPMI_ECC_CURVE,
        Q: *mut *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EC_Ephemeral_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        curveID: TPMI_ECC_CURVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EC_Ephemeral_Finish(
        esysContext: *mut ESYS_CONTEXT,
        Q: *mut *mut TPM2B_ECC_POINT,
        counter: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_VerifySignature(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digest: *const TPM2B_DIGEST,
        signature: *const TPMT_SIGNATURE,
        validation: *mut *mut TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_VerifySignature_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digest: *const TPM2B_DIGEST,
        signature: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_VerifySignature_Finish(
        esysContext: *mut ESYS_CONTEXT,
        validation: *mut *mut TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Sign(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digest: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        validation: *const TPMT_TK_HASHCHECK,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Sign_Async(
        esysContext: *mut ESYS_CONTEXT,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digest: *const TPM2B_DIGEST,
        inScheme: *const TPMT_SIG_SCHEME,
        validation: *const TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Sign_Finish(
        esysContext: *mut ESYS_CONTEXT,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetCommandCodeAuditStatus(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auditAlg: TPMI_ALG_HASH,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetCommandCodeAuditStatus_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auditAlg: TPMI_ALG_HASH,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetCommandCodeAuditStatus_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Extend(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digests: *const TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Extend_Async(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        digests: *const TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Extend_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Event(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        eventData: *const TPM2B_EVENT,
        digests: *mut *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Event_Async(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        eventData: *const TPM2B_EVENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Event_Finish(
        esysContext: *mut ESYS_CONTEXT,
        digests: *mut *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Read(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrSelectionIn: *const TPML_PCR_SELECTION,
        pcrUpdateCounter: *mut UINT32,
        pcrSelectionOut: *mut *mut TPML_PCR_SELECTION,
        pcrValues: *mut *mut TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Read_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrSelectionIn: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Read_Finish(
        esysContext: *mut ESYS_CONTEXT,
        pcrUpdateCounter: *mut UINT32,
        pcrSelectionOut: *mut *mut TPML_PCR_SELECTION,
        pcrValues: *mut *mut TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Allocate(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrAllocation: *const TPML_PCR_SELECTION,
        allocationSuccess: *mut TPMI_YES_NO,
        maxPCR: *mut UINT32,
        sizeNeeded: *mut UINT32,
        sizeAvailable: *mut UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Allocate_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrAllocation: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Allocate_Finish(
        esysContext: *mut ESYS_CONTEXT,
        allocationSuccess: *mut TPMI_YES_NO,
        maxPCR: *mut UINT32,
        sizeNeeded: *mut UINT32,
        sizeAvailable: *mut UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthPolicy(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
        pcrNum: TPMI_DH_PCR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthPolicy_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
        pcrNum: TPMI_DH_PCR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthPolicy_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthValue(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthValue_Async(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_SetAuthValue_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Reset(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Reset_Async(
        esysContext: *mut ESYS_CONTEXT,
        pcrHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PCR_Reset_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySigned(
        esysContext: *mut ESYS_CONTEXT,
        authObject: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        auth: *const TPMT_SIGNATURE,
        timeout: *mut *mut TPM2B_TIMEOUT,
        policyTicket: *mut *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySigned_Async(
        esysContext: *mut ESYS_CONTEXT,
        authObject: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        auth: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySigned_Finish(
        esysContext: *mut ESYS_CONTEXT,
        timeout: *mut *mut TPM2B_TIMEOUT,
        policyTicket: *mut *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySecret(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
        timeout: *mut *mut TPM2B_TIMEOUT,
        policyTicket: *mut *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySecret_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nonceTPM: *const TPM2B_NONCE,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        expiration: INT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicySecret_Finish(
        esysContext: *mut ESYS_CONTEXT,
        timeout: *mut *mut TPM2B_TIMEOUT,
        policyTicket: *mut *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTicket(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        timeout: *const TPM2B_TIMEOUT,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        authName: *const TPM2B_NAME,
        ticket: *const TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTicket_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        timeout: *const TPM2B_TIMEOUT,
        cpHashA: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        authName: *const TPM2B_NAME,
        ticket: *const TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTicket_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyOR(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pHashList: *const TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyOR_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pHashList: *const TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyOR_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPCR(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrDigest: *const TPM2B_DIGEST,
        pcrs: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPCR_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        pcrDigest: *const TPM2B_DIGEST,
        pcrs: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPCR_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyLocality(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        locality: TPMA_LOCALITY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyLocality_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        locality: TPMA_LOCALITY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyLocality_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNV(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNV_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNV_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCounterTimer(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCounterTimer_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        operandB: *const TPM2B_OPERAND,
        offset: UINT16,
        operation: TPM2_EO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCounterTimer_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCommandCode(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        code: TPM2_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCommandCode_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        code: TPM2_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCommandCode_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPhysicalPresence(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPhysicalPresence_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPhysicalPresence_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCpHash(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        cpHashA: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCpHash_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        cpHashA: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyCpHash_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNameHash(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nameHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNameHash_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nameHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNameHash_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyDuplicationSelect(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        objectName: *const TPM2B_NAME,
        newParentName: *const TPM2B_NAME,
        includeObject: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyDuplicationSelect_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        objectName: *const TPM2B_NAME,
        newParentName: *const TPM2B_NAME,
        includeObject: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyDuplicationSelect_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorize(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        approvedPolicy: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        keySign: *const TPM2B_NAME,
        checkTicket: *const TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorize_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        approvedPolicy: *const TPM2B_DIGEST,
        policyRef: *const TPM2B_NONCE,
        keySign: *const TPM2B_NAME,
        checkTicket: *const TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorize_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthValue(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthValue_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthValue_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPassword(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPassword_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyPassword_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyGetDigest(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        policyDigest: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyGetDigest_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyGetDigest_Finish(
        esysContext: *mut ESYS_CONTEXT,
        policyDigest: *mut *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNvWritten(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        writtenSet: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNvWritten_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        writtenSet: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyNvWritten_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTemplate(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        templateHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTemplate_Async(
        esysContext: *mut ESYS_CONTEXT,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        templateHash: *const TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyTemplate_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorizeNV(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorizeNV_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        policySession: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PolicyAuthorizeNV_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreatePrimary(
        esysContext: *mut ESYS_CONTEXT,
        primaryHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
        objectHandle: *mut ESYS_TR,
        outPublic: *mut *mut TPM2B_PUBLIC,
        creationData: *mut *mut TPM2B_CREATION_DATA,
        creationHash: *mut *mut TPM2B_DIGEST,
        creationTicket: *mut *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreatePrimary_Async(
        esysContext: *mut ESYS_CONTEXT,
        primaryHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inSensitive: *const TPM2B_SENSITIVE_CREATE,
        inPublic: *const TPM2B_PUBLIC,
        outsideInfo: *const TPM2B_DATA,
        creationPCR: *const TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_CreatePrimary_Finish(
        esysContext: *mut ESYS_CONTEXT,
        objectHandle: *mut ESYS_TR,
        outPublic: *mut *mut TPM2B_PUBLIC,
        creationData: *mut *mut TPM2B_CREATION_DATA,
        creationHash: *mut *mut TPM2B_DIGEST,
        creationTicket: *mut *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyControl(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        enable: ESYS_TR,
        state: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyControl_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        enable: ESYS_TR,
        state: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyControl_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetPrimaryPolicy(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetPrimaryPolicy_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        authPolicy: *const TPM2B_DIGEST,
        hashAlg: TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetPrimaryPolicy_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangePPS(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangePPS_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangePPS_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangeEPS(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangeEPS_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ChangeEPS_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Clear(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Clear_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Clear_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClearControl(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        disable: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClearControl_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        disable: TPMI_YES_NO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClearControl_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyChangeAuth(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyChangeAuth_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_HierarchyChangeAuth_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackLockReset(
        esysContext: *mut ESYS_CONTEXT,
        lockHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackLockReset_Async(
        esysContext: *mut ESYS_CONTEXT,
        lockHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackLockReset_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackParameters(
        esysContext: *mut ESYS_CONTEXT,
        lockHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newMaxTries: UINT32,
        newRecoveryTime: UINT32,
        lockoutRecovery: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackParameters_Async(
        esysContext: *mut ESYS_CONTEXT,
        lockHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newMaxTries: UINT32,
        newRecoveryTime: UINT32,
        lockoutRecovery: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_DictionaryAttackParameters_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PP_Commands(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PP_Commands_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        setList: *const TPML_CC,
        clearList: *const TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_PP_Commands_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetAlgorithmSet(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        algorithmSet: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetAlgorithmSet_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        algorithmSet: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_SetAlgorithmSet_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeStart(
        esysContext: *mut ESYS_CONTEXT,
        authorization: ESYS_TR,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fuDigest: *const TPM2B_DIGEST,
        manifestSignature: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeStart_Async(
        esysContext: *mut ESYS_CONTEXT,
        authorization: ESYS_TR,
        keyHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fuDigest: *const TPM2B_DIGEST,
        manifestSignature: *const TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeStart_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeData(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fuData: *const TPM2B_MAX_BUFFER,
        nextDigest: *mut *mut TPMT_HA,
        firstDigest: *mut *mut TPMT_HA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeData_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        fuData: *const TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FieldUpgradeData_Finish(
        esysContext: *mut ESYS_CONTEXT,
        nextDigest: *mut *mut TPMT_HA,
        firstDigest: *mut *mut TPMT_HA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FirmwareRead(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        sequenceNumber: UINT32,
        fuData: *mut *mut TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FirmwareRead_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        sequenceNumber: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FirmwareRead_Finish(
        esysContext: *mut ESYS_CONTEXT,
        fuData: *mut *mut TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextSave(
        esysContext: *mut ESYS_CONTEXT,
        saveHandle: ESYS_TR,
        context: *mut *mut TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextSave_Async(esysContext: *mut ESYS_CONTEXT, saveHandle: ESYS_TR) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextSave_Finish(
        esysContext: *mut ESYS_CONTEXT,
        context: *mut *mut TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextLoad(
        esysContext: *mut ESYS_CONTEXT,
        context: *const TPMS_CONTEXT,
        loadedHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextLoad_Async(
        esysContext: *mut ESYS_CONTEXT,
        context: *const TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ContextLoad_Finish(
        esysContext: *mut ESYS_CONTEXT,
        loadedHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FlushContext(esysContext: *mut ESYS_CONTEXT, flushHandle: ESYS_TR) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FlushContext_Async(esysContext: *mut ESYS_CONTEXT, flushHandle: ESYS_TR)
        -> TSS2_RC;
}
extern "C" {
    pub fn Esys_FlushContext_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EvictControl(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        persistentHandle: TPMI_DH_PERSISTENT,
        newObjectHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EvictControl_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        objectHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        persistentHandle: TPMI_DH_PERSISTENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_EvictControl_Finish(
        esysContext: *mut ESYS_CONTEXT,
        newObjectHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadClock(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        currentTime: *mut *mut TPMS_TIME_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadClock_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ReadClock_Finish(
        esysContext: *mut ESYS_CONTEXT,
        currentTime: *mut *mut TPMS_TIME_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockSet(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newTime: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockSet_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newTime: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockSet_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockRateAdjust(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        rateAdjust: TPM2_CLOCK_ADJUST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockRateAdjust_Async(
        esysContext: *mut ESYS_CONTEXT,
        auth: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        rateAdjust: TPM2_CLOCK_ADJUST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_ClockRateAdjust_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCapability(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        capability: TPM2_CAP,
        property: UINT32,
        propertyCount: UINT32,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut *mut TPMS_CAPABILITY_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCapability_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        capability: TPM2_CAP,
        property: UINT32,
        propertyCount: UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_GetCapability_Finish(
        esysContext: *mut ESYS_CONTEXT,
        moreData: *mut TPMI_YES_NO,
        capabilityData: *mut *mut TPMS_CAPABILITY_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TestParms(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        parameters: *const TPMT_PUBLIC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TestParms_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        parameters: *const TPMT_PUBLIC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_TestParms_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_DefineSpace(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        publicInfo: *const TPM2B_NV_PUBLIC,
        nvHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_DefineSpace_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        auth: *const TPM2B_AUTH,
        publicInfo: *const TPM2B_NV_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_DefineSpace_Finish(
        esysContext: *mut ESYS_CONTEXT,
        nvHandle: *mut ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpace(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpace_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpace_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpaceSpecial(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        platform: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpaceSpecial_Async(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        platform: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_UndefineSpaceSpecial_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadPublic(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        nvPublic: *mut *mut TPM2B_NV_PUBLIC,
        nvName: *mut *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadPublic_Async(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadPublic_Finish(
        esysContext: *mut ESYS_CONTEXT,
        nvPublic: *mut *mut TPM2B_NV_PUBLIC,
        nvName: *mut *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Write(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_NV_BUFFER,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Write_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_NV_BUFFER,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Write_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Increment(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Increment_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Increment_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Extend(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Extend_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        data: *const TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Extend_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_SetBits(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        bits: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_SetBits_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        bits: UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_SetBits_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_WriteLock(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_WriteLock_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_WriteLock_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_GlobalWriteLock(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_GlobalWriteLock_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_GlobalWriteLock_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Read(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        size: UINT16,
        offset: UINT16,
        data: *mut *mut TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Read_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        size: UINT16,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Read_Finish(
        esysContext: *mut ESYS_CONTEXT,
        data: *mut *mut TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadLock(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadLock_Async(
        esysContext: *mut ESYS_CONTEXT,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ReadLock_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ChangeAuth(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ChangeAuth_Async(
        esysContext: *mut ESYS_CONTEXT,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        newAuth: *const TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_ChangeAuth_Finish(esysContext: *mut ESYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Certify(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        size: UINT16,
        offset: UINT16,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Certify_Async(
        esysContext: *mut ESYS_CONTEXT,
        signHandle: ESYS_TR,
        authHandle: ESYS_TR,
        nvIndex: ESYS_TR,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        qualifyingData: *const TPM2B_DATA,
        inScheme: *const TPMT_SIG_SCHEME,
        size: UINT16,
        offset: UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_NV_Certify_Finish(
        esysContext: *mut ESYS_CONTEXT,
        certifyInfo: *mut *mut TPM2B_ATTEST,
        signature: *mut *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Vendor_TCG_Test(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inputData: *const TPM2B_DATA,
        outputData: *mut *mut TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Vendor_TCG_Test_Async(
        esysContext: *mut ESYS_CONTEXT,
        shandle1: ESYS_TR,
        shandle2: ESYS_TR,
        shandle3: ESYS_TR,
        inputData: *const TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Vendor_TCG_Test_Finish(
        esysContext: *mut ESYS_CONTEXT,
        outputData: *mut *mut TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Esys_Free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn Esys_GetSysContext(
        esys_context: *mut ESYS_CONTEXT,
        sys_context: *mut *mut TSS2_SYS_CONTEXT,
    ) -> TSS2_RC;
}
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Tss2_TctiLdr_Finalize(context: *mut *mut TSS2_TCTI_CONTEXT);
}
extern "C" {
    pub fn Tss2_TctiLdr_Initialize_Ex(
        name: *const ::std::os::raw::c_char,
        conf: *const ::std::os::raw::c_char,
        context: *mut *mut TSS2_TCTI_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_TctiLdr_Initialize(
        nameConf: *const ::std::os::raw::c_char,
        context: *mut *mut TSS2_TCTI_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_TctiLdr_GetInfo(
        name: *const ::std::os::raw::c_char,
        info: *mut *mut TSS2_TCTI_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_TctiLdr_FreeInfo(info: *mut *mut TSS2_TCTI_INFO);
}
extern "C" {
    pub fn Tss2_MU_INT8_Marshal(
        src: INT8,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT8_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut INT8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT16_Marshal(
        src: INT16,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT16_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut INT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT32_Marshal(
        src: INT32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT32_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut INT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT64_Marshal(
        src: INT64,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_INT64_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut INT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT8_Marshal(
        src: UINT8,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT8_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut UINT8,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT16_Marshal(
        src: UINT16,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT16_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut UINT16,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT32_Marshal(
        src: UINT32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT32_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut UINT32,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT64_Marshal(
        src: UINT64,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_UINT64_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut UINT64,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_CC_Marshal(
        src: TPM2_CC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_CC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_ST_Marshal(
        src: TPM2_ST,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_ST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2_ST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_ALGORITHM_Marshal(
        src: TPMA_ALGORITHM,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_ALGORITHM_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_ALGORITHM,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_CC_Marshal(
        src: TPMA_CC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_CC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_LOCALITY_Marshal(
        src: TPMA_LOCALITY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_LOCALITY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_LOCALITY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_NV_Marshal(
        src: TPMA_NV,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_NV_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_NV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_OBJECT_Marshal(
        src: TPMA_OBJECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_OBJECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_PERMANENT_Marshal(
        src: TPMA_PERMANENT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_PERMANENT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_PERMANENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_SESSION_Marshal(
        src: TPMA_SESSION,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_SESSION_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_SESSION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_STARTUP_CLEAR_Marshal(
        src: TPMA_STARTUP_CLEAR,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMA_STARTUP_CLEAR_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMA_STARTUP_CLEAR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_DIGEST_Marshal(
        src: *const TPM2B_DIGEST,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_DIGEST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ATTEST_Marshal(
        src: *const TPM2B_ATTEST,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ATTEST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_ATTEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NAME_Marshal(
        src: *const TPM2B_NAME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NAME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_MAX_NV_BUFFER_Marshal(
        src: *const TPM2B_MAX_NV_BUFFER,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_MAX_NV_BUFFER_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_MAX_NV_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_DATA_Marshal(
        src: *const TPM2B_SENSITIVE_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_SENSITIVE_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ECC_PARAMETER_Marshal(
        src: *const TPM2B_ECC_PARAMETER,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ECC_PARAMETER_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_ECC_PARAMETER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PUBLIC_KEY_RSA_Marshal(
        src: *const TPM2B_PUBLIC_KEY_RSA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PUBLIC_KEY_RSA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_PUBLIC_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PRIVATE_KEY_RSA_Marshal(
        src: *const TPM2B_PRIVATE_KEY_RSA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PRIVATE_KEY_RSA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_PRIVATE_KEY_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PRIVATE_Marshal(
        src: *const TPM2B_PRIVATE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PRIVATE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_PRIVATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CONTEXT_SENSITIVE_Marshal(
        src: *const TPM2B_CONTEXT_SENSITIVE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CONTEXT_SENSITIVE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_CONTEXT_SENSITIVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CONTEXT_DATA_Marshal(
        src: *const TPM2B_CONTEXT_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CONTEXT_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_CONTEXT_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_DATA_Marshal(
        src: *const TPM2B_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SYM_KEY_Marshal(
        src: *const TPM2B_SYM_KEY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SYM_KEY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_SYM_KEY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ECC_POINT_Marshal(
        src: *const TPM2B_ECC_POINT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ECC_POINT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NV_PUBLIC_Marshal(
        src: *const TPM2B_NV_PUBLIC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NV_PUBLIC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_NV_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_Marshal(
        src: *const TPM2B_SENSITIVE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_SENSITIVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_CREATE_Marshal(
        src: *const TPM2B_SENSITIVE_CREATE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_SENSITIVE_CREATE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_SENSITIVE_CREATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CREATION_DATA_Marshal(
        src: *const TPM2B_CREATION_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_CREATION_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_CREATION_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PUBLIC_Marshal(
        src: *const TPM2B_PUBLIC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_PUBLIC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ENCRYPTED_SECRET_Marshal(
        src: *const TPM2B_ENCRYPTED_SECRET,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ENCRYPTED_SECRET_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ID_OBJECT_Marshal(
        src: *const TPM2B_ID_OBJECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_ID_OBJECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_ID_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_IV_Marshal(
        src: *const TPM2B_IV,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_IV_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_IV,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_AUTH_Marshal(
        src: *const TPM2B_AUTH,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_AUTH_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_EVENT_Marshal(
        src: *const TPM2B_EVENT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_EVENT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_EVENT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_MAX_BUFFER_Marshal(
        src: *const TPM2B_MAX_BUFFER,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_MAX_BUFFER_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_MAX_BUFFER,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NONCE_Marshal(
        src: *const TPM2B_NONCE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_NONCE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_NONCE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_OPERAND_Marshal(
        src: *const TPM2B_OPERAND,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_OPERAND_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_OPERAND,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_TIMEOUT_Marshal(
        src: *const TPM2B_TIMEOUT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_TIMEOUT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_TIMEOUT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_TEMPLATE_Marshal(
        src: *const TPM2B_TEMPLATE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2B_TEMPLATE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPM2B_TEMPLATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CONTEXT_Marshal(
        src: *const TPMS_CONTEXT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CONTEXT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CONTEXT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TIME_INFO_Marshal(
        src: *const TPMS_TIME_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TIME_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_TIME_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ECC_POINT_Marshal(
        src: *const TPMS_ECC_POINT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ECC_POINT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ECC_POINT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_PUBLIC_Marshal(
        src: *const TPMS_NV_PUBLIC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_PUBLIC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_NV_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALG_PROPERTY_Marshal(
        src: *const TPMS_ALG_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALG_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ALG_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALGORITHM_DESCRIPTION_Marshal(
        src: *const TPMS_ALGORITHM_DESCRIPTION,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALGORITHM_DESCRIPTION_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ALGORITHM_DESCRIPTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_PROPERTY_Marshal(
        src: *const TPMS_TAGGED_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_TAGGED_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_POLICY_Marshal(
        src: *const TPMS_TAGGED_POLICY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_POLICY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_TAGGED_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CLOCK_INFO_Marshal(
        src: *const TPMS_CLOCK_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CLOCK_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CLOCK_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TIME_ATTEST_INFO_Marshal(
        src: *const TPMS_TIME_ATTEST_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TIME_ATTEST_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_TIME_ATTEST_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CERTIFY_INFO_Marshal(
        src: *const TPMS_CERTIFY_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CERTIFY_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CERTIFY_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_COMMAND_AUDIT_INFO_Marshal(
        src: *const TPMS_COMMAND_AUDIT_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_COMMAND_AUDIT_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_COMMAND_AUDIT_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SESSION_AUDIT_INFO_Marshal(
        src: *const TPMS_SESSION_AUDIT_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SESSION_AUDIT_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SESSION_AUDIT_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CREATION_INFO_Marshal(
        src: *const TPMS_CREATION_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CREATION_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CREATION_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_CERTIFY_INFO_Marshal(
        src: *const TPMS_NV_CERTIFY_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_CERTIFY_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_NV_CERTIFY_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AUTH_COMMAND_Marshal(
        src: *const TPMS_AUTH_COMMAND,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AUTH_COMMAND_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_AUTH_COMMAND,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AUTH_RESPONSE_Marshal(
        src: *const TPMS_AUTH_RESPONSE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AUTH_RESPONSE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_AUTH_RESPONSE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SENSITIVE_CREATE_Marshal(
        src: *const TPMS_SENSITIVE_CREATE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SENSITIVE_CREATE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SENSITIVE_CREATE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_HASH_Marshal(
        src: *const TPMS_SCHEME_HASH,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_HASH_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SCHEME_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_ECDAA_Marshal(
        src: *const TPMS_SCHEME_ECDAA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_ECDAA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SCHEME_ECDAA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_XOR_Marshal(
        src: *const TPMS_SCHEME_XOR,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SCHEME_XOR_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SCHEME_XOR,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SIGNATURE_RSA_Marshal(
        src: *const TPMS_SIGNATURE_RSA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SIGNATURE_RSA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SIGNATURE_RSA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SIGNATURE_ECC_Marshal(
        src: *const TPMS_SIGNATURE_ECC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SIGNATURE_ECC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SIGNATURE_ECC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_PIN_COUNTER_PARAMETERS_Marshal(
        src: *const TPMS_NV_PIN_COUNTER_PARAMETERS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_PIN_COUNTER_PARAMETERS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_NV_PIN_COUNTER_PARAMETERS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CONTEXT_DATA_Marshal(
        src: *const TPMS_CONTEXT_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CONTEXT_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CONTEXT_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_PCR_SELECT_Marshal(
        src: *const TPMS_PCR_SELECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_PCR_SELECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_PCR_SELECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_PCR_SELECTION_Marshal(
        src: *const TPMS_PCR_SELECTION,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_PCR_SELECTION_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_PCR_SELECT_Marshal(
        src: *const TPMS_TAGGED_PCR_SELECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_TAGGED_PCR_SELECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_TAGGED_PCR_SELECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_QUOTE_INFO_Marshal(
        src: *const TPMS_QUOTE_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_QUOTE_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_QUOTE_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CREATION_DATA_Marshal(
        src: *const TPMS_CREATION_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CREATION_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CREATION_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ECC_PARMS_Marshal(
        src: *const TPMS_ECC_PARMS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ECC_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ECC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ATTEST_Marshal(
        src: *const TPMS_ATTEST,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ATTEST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ATTEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALGORITHM_DETAIL_ECC_Marshal(
        src: *const TPMS_ALGORITHM_DETAIL_ECC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ALGORITHM_DETAIL_ECC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ALGORITHM_DETAIL_ECC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CAPABILITY_DATA_Marshal(
        src: *const TPMS_CAPABILITY_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_CAPABILITY_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_CAPABILITY_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_KEYEDHASH_PARMS_Marshal(
        src: *const TPMS_KEYEDHASH_PARMS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_KEYEDHASH_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_KEYEDHASH_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_RSA_PARMS_Marshal(
        src: *const TPMS_RSA_PARMS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_RSA_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_RSA_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SYMCIPHER_PARMS_Marshal(
        src: *const TPMS_SYMCIPHER_PARMS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_SYMCIPHER_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_SYMCIPHER_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AC_OUTPUT_Marshal(
        src: *const TPMS_AC_OUTPUT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_AC_OUTPUT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_AC_OUTPUT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ID_OBJECT_Marshal(
        src: *const TPMS_ID_OBJECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ID_OBJECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ID_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ACT_DATA_Marshal(
        src: *const TPMS_ACT_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_ACT_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_ACT_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_DIGEST_CERTIFY_INFO_Marshal(
        src: *const TPMS_NV_DIGEST_CERTIFY_INFO,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_NV_DIGEST_CERTIFY_INFO_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMS_NV_DIGEST_CERTIFY_INFO,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_CC_Marshal(
        src: *const TPML_CC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_CC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_CC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_CCA_Marshal(
        src: *const TPML_CCA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_CCA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_CCA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ALG_Marshal(
        src: *const TPML_ALG,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ALG_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_ALG,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_HANDLE_Marshal(
        src: *const TPML_HANDLE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_HANDLE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_HANDLE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_DIGEST_Marshal(
        src: *const TPML_DIGEST,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_DIGEST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_DIGEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_DIGEST_VALUES_Marshal(
        src: *const TPML_DIGEST_VALUES,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_DIGEST_VALUES_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_DIGEST_VALUES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_PCR_SELECTION_Marshal(
        src: *const TPML_PCR_SELECTION,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_PCR_SELECTION_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_PCR_SELECTION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ALG_PROPERTY_Marshal(
        src: *const TPML_ALG_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ALG_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_ALG_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ECC_CURVE_Marshal(
        src: *const TPML_ECC_CURVE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ECC_CURVE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_ECC_CURVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_PCR_PROPERTY_Marshal(
        src: *const TPML_TAGGED_PCR_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_PCR_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_TAGGED_PCR_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_TPM_PROPERTY_Marshal(
        src: *const TPML_TAGGED_TPM_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_TPM_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_TAGGED_TPM_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_INTEL_PTT_PROPERTY_Marshal(
        src: *const TPML_INTEL_PTT_PROPERTY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_INTEL_PTT_PROPERTY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_INTEL_PTT_PROPERTY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_AC_CAPABILITIES_Marshal(
        src: *const TPML_AC_CAPABILITIES,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_AC_CAPABILITIES_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_AC_CAPABILITIES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_POLICY_Marshal(
        src: *const TPML_TAGGED_POLICY,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_TAGGED_POLICY_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_TAGGED_POLICY,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ACT_DATA_Marshal(
        src: *const TPML_ACT_DATA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPML_ACT_DATA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPML_ACT_DATA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_HA_Marshal(
        src: *const TPMU_HA,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_HA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_HA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_CAPABILITIES_Marshal(
        src: *const TPMU_CAPABILITIES,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_CAPABILITIES_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_CAPABILITIES,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ATTEST_Marshal(
        src: *const TPMU_ATTEST,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ATTEST_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_ATTEST,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SYM_KEY_BITS_Marshal(
        src: *const TPMU_SYM_KEY_BITS,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SYM_KEY_BITS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SYM_KEY_BITS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SYM_MODE_Marshal(
        src: *const TPMU_SYM_MODE,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SYM_MODE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SYM_MODE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SIG_SCHEME_Marshal(
        src: *const TPMU_SIG_SCHEME,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SIG_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_KDF_SCHEME_Marshal(
        src: *const TPMU_KDF_SCHEME,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_KDF_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_KDF_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ASYM_SCHEME_Marshal(
        src: *const TPMU_ASYM_SCHEME,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ASYM_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_ASYM_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SCHEME_KEYEDHASH_Marshal(
        src: *const TPMU_SCHEME_KEYEDHASH,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SCHEME_KEYEDHASH_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SCHEME_KEYEDHASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SIGNATURE_Marshal(
        src: *const TPMU_SIGNATURE,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SIGNATURE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SENSITIVE_COMPOSITE_Marshal(
        src: *const TPMU_SENSITIVE_COMPOSITE,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_SENSITIVE_COMPOSITE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_SENSITIVE_COMPOSITE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ENCRYPTED_SECRET_Marshal(
        src: *const TPMU_ENCRYPTED_SECRET,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_ENCRYPTED_SECRET_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_ENCRYPTED_SECRET,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_PUBLIC_PARMS_Marshal(
        src: *const TPMU_PUBLIC_PARMS,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_PUBLIC_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_PUBLIC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_PUBLIC_ID_Marshal(
        src: *const TPMU_PUBLIC_ID,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_PUBLIC_ID_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_PUBLIC_ID,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_NAME_Marshal(
        src: *const TPMU_NAME,
        selector_value: u32,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMU_NAME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        selector_value: u32,
        dest: *mut TPMU_NAME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_HA_Marshal(
        src: *const TPMT_HA,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_HA_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_HA,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SYM_DEF_Marshal(
        src: *const TPMT_SYM_DEF,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SYM_DEF_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_SYM_DEF,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SYM_DEF_OBJECT_Marshal(
        src: *const TPMT_SYM_DEF_OBJECT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SYM_DEF_OBJECT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_SYM_DEF_OBJECT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_KEYEDHASH_SCHEME_Marshal(
        src: *const TPMT_KEYEDHASH_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_KEYEDHASH_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_KEYEDHASH_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SIG_SCHEME_Marshal(
        src: *const TPMT_SIG_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SIG_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_SIG_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_KDF_SCHEME_Marshal(
        src: *const TPMT_KDF_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_KDF_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_KDF_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_ASYM_SCHEME_Marshal(
        src: *const TPMT_ASYM_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_ASYM_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_ASYM_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_RSA_SCHEME_Marshal(
        src: *const TPMT_RSA_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_RSA_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_RSA_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_RSA_DECRYPT_Marshal(
        src: *const TPMT_RSA_DECRYPT,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_RSA_DECRYPT_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_RSA_DECRYPT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_ECC_SCHEME_Marshal(
        src: *const TPMT_ECC_SCHEME,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_ECC_SCHEME_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_ECC_SCHEME,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SIGNATURE_Marshal(
        src: *const TPMT_SIGNATURE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SIGNATURE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_SIGNATURE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SENSITIVE_Marshal(
        src: *const TPMT_SENSITIVE,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_SENSITIVE_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_SENSITIVE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_PUBLIC_Marshal(
        src: *const TPMT_PUBLIC,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_PUBLIC_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_PUBLIC,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_PUBLIC_PARMS_Marshal(
        src: *const TPMT_PUBLIC_PARMS,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_PUBLIC_PARMS_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_PUBLIC_PARMS,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_CREATION_Marshal(
        src: *const TPMT_TK_CREATION,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_CREATION_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_TK_CREATION,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_VERIFIED_Marshal(
        src: *const TPMT_TK_VERIFIED,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_VERIFIED_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_TK_VERIFIED,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_AUTH_Marshal(
        src: *const TPMT_TK_AUTH,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_AUTH_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_TK_AUTH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_HASHCHECK_Marshal(
        src: *const TPMT_TK_HASHCHECK,
        buffer: *mut u8,
        buffer_size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMT_TK_HASHCHECK_Unmarshal(
        buffer: *const u8,
        buffer_size: size_t,
        offset: *mut size_t,
        dest: *mut TPMT_TK_HASHCHECK,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_HANDLE_Marshal(
        in_: TPM2_HANDLE,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_HANDLE_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut TPM2_HANDLE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMI_ALG_HASH_Marshal(
        in_: TPMI_ALG_HASH,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMI_ALG_HASH_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut TPMI_ALG_HASH,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_BYTE_Marshal(
        in_: BYTE,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_BYTE_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut BYTE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_SE_Marshal(
        in_: TPM2_SE,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_SE_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut TPM2_SE,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_NT_Marshal(
        in_: TPM2_NT,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPM2_NT_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut TPM2_NT,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_EMPTY_Marshal(
        in_: *const TPMS_EMPTY,
        buffer: *mut u8,
        size: size_t,
        offset: *mut size_t,
    ) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_MU_TPMS_EMPTY_Unmarshal(
        buffer: *const u8,
        size: size_t,
        offset: *mut size_t,
        out: *mut TPMS_EMPTY,
    ) -> TSS2_RC;
}
